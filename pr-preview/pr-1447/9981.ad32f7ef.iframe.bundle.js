"use strict";(self.webpackChunksam_design_system=self.webpackChunksam_design_system||[]).push([[9981],{"./node_modules/@angular/router/fesm2022/testing.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{c1:()=>RouterTestingModule});var asyncToGenerator=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),common=__webpack_require__("./node_modules/@angular/common/fesm2022/common.mjs"),Subject=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subject.js");function normalizeQueryParams(params){return params&&"?"!==params[0]?"?"+params:params}class SpyLocation{constructor(){this.urlChanges=[],this._history=[new LocationState("","",null)],this._historyIndex=0,this._subject=new core.EventEmitter,this._basePath="",this._locationStrategy=null,this._urlChangeListeners=[],this._urlChangeSubscription=null}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}setInitialPath(url){this._history[this._historyIndex].path=url}setBaseHref(url){this._basePath=url}path(){return this._history[this._historyIndex].path}getState(){return this._history[this._historyIndex].state}isCurrentPathEqualTo(path,query=""){const givenPath=path.endsWith("/")?path.substring(0,path.length-1):path;return(this.path().endsWith("/")?this.path().substring(0,this.path().length-1):this.path())==givenPath+(query.length>0?"?"+query:"")}simulateUrlPop(pathname){this._subject.emit({url:pathname,pop:!0,type:"popstate"})}simulateHashChange(pathname){const path=this.prepareExternalUrl(pathname);this.pushHistory(path,"",null),this.urlChanges.push("hash: "+pathname),this._subject.emit({url:pathname,pop:!0,type:"popstate"}),this._subject.emit({url:pathname,pop:!0,type:"hashchange"})}prepareExternalUrl(url){return url.length>0&&!url.startsWith("/")&&(url="/"+url),this._basePath+url}go(path,query="",state=null){path=this.prepareExternalUrl(path),this.pushHistory(path,query,state);const locationState=this._history[this._historyIndex-1];if(locationState.path==path&&locationState.query==query)return;const url=path+(query.length>0?"?"+query:"");this.urlChanges.push(url),this._notifyUrlChangeListeners(path+normalizeQueryParams(query),state)}replaceState(path,query="",state=null){path=this.prepareExternalUrl(path);const history=this._history[this._historyIndex];if(history.state=state,history.path==path&&history.query==query)return;history.path=path,history.query=query;const url=path+(query.length>0?"?"+query:"");this.urlChanges.push("replace: "+url),this._notifyUrlChangeListeners(path+normalizeQueryParams(query),state)}forward(){this._historyIndex<this._history.length-1&&(this._historyIndex++,this._subject.emit({url:this.path(),state:this.getState(),pop:!0,type:"popstate"}))}back(){this._historyIndex>0&&(this._historyIndex--,this._subject.emit({url:this.path(),state:this.getState(),pop:!0,type:"popstate"}))}historyGo(relativePosition=0){const nextPageIndex=this._historyIndex+relativePosition;nextPageIndex>=0&&nextPageIndex<this._history.length&&(this._historyIndex=nextPageIndex,this._subject.emit({url:this.path(),state:this.getState(),pop:!0,type:"popstate"}))}onUrlChange(fn){return this._urlChangeListeners.push(fn),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe((v=>{this._notifyUrlChangeListeners(v.url,v.state)}))),()=>{const fnIndex=this._urlChangeListeners.indexOf(fn);this._urlChangeListeners.splice(fnIndex,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(url="",state){this._urlChangeListeners.forEach((fn=>fn(url,state)))}subscribe(onNext,onThrow,onReturn){return this._subject.subscribe({next:onNext,error:onThrow,complete:onReturn})}normalize(url){return null}pushHistory(path,query,state){this._historyIndex>0&&this._history.splice(this._historyIndex+1),this._history.push(new LocationState(path,query,state)),this._historyIndex=this._history.length-1}static#_=this.ɵfac=function SpyLocation_Factory(t){return new(t||SpyLocation)};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:SpyLocation,factory:SpyLocation.ɵfac})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](SpyLocation,[{type:core.Injectable}],null,null);class LocationState{constructor(path,query,state){this.path=path,this.query=query,this.state=state}}class MockLocationStrategy extends common.LocationStrategy{constructor(){super(),this.internalBaseHref="/",this.internalPath="/",this.internalTitle="",this.urlChanges=[],this._subject=new core.EventEmitter,this.stateChanges=[]}simulatePopState(url){this.internalPath=url,this._subject.emit(new _MockPopStateEvent(this.path()))}path(includeHash=!1){return this.internalPath}prepareExternalUrl(internal){return internal.startsWith("/")&&this.internalBaseHref.endsWith("/")?this.internalBaseHref+internal.substring(1):this.internalBaseHref+internal}pushState(ctx,title,path,query){this.stateChanges.push(ctx),this.internalTitle=title;const url=path+(query.length>0?"?"+query:"");this.internalPath=url;const externalUrl=this.prepareExternalUrl(url);this.urlChanges.push(externalUrl)}replaceState(ctx,title,path,query){this.stateChanges[(this.stateChanges.length||1)-1]=ctx,this.internalTitle=title;const url=path+(query.length>0?"?"+query:"");this.internalPath=url;const externalUrl=this.prepareExternalUrl(url);this.urlChanges.push("replace: "+externalUrl)}onPopState(fn){this._subject.subscribe({next:fn})}getBaseHref(){return this.internalBaseHref}back(){if(this.urlChanges.length>0){this.urlChanges.pop(),this.stateChanges.pop();const nextUrl=this.urlChanges.length>0?this.urlChanges[this.urlChanges.length-1]:"";this.simulatePopState(nextUrl)}}forward(){throw"not implemented"}getState(){return this.stateChanges[(this.stateChanges.length||1)-1]}static#_=this.ɵfac=function MockLocationStrategy_Factory(t){return new(t||MockLocationStrategy)};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:MockLocationStrategy,factory:MockLocationStrategy.ɵfac})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](MockLocationStrategy,[{type:core.Injectable}],(function(){return[]}),null);class _MockPopStateEvent{constructor(newUrl){this.newUrl=newUrl,this.pop=!0,this.type="popstate"}}const urlParse=/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;function parseUrl(urlStr,baseHref){let serverBase,parsedUrl;/^((http[s]?|ftp):\/\/)/.test(urlStr)||(serverBase="http://empty.com/");try{parsedUrl=new URL(urlStr,serverBase)}catch(e){const result=urlParse.exec(serverBase||""+urlStr);if(!result)throw new Error(`Invalid URL: ${urlStr} with base: ${baseHref}`);const hostSplit=result[4].split(":");parsedUrl={protocol:result[1],hostname:hostSplit[0],port:hostSplit[1]||"",pathname:result[5],search:result[6],hash:result[8]}}return parsedUrl.pathname&&0===parsedUrl.pathname.indexOf(baseHref)&&(parsedUrl.pathname=parsedUrl.pathname.substring(baseHref.length)),{hostname:!serverBase&&parsedUrl.hostname||"",protocol:!serverBase&&parsedUrl.protocol||"",port:!serverBase&&parsedUrl.port||"",pathname:parsedUrl.pathname||"/",search:parsedUrl.search||"",hash:parsedUrl.hash||""}}const MOCK_PLATFORM_LOCATION_CONFIG=new core.InjectionToken("MOCK_PLATFORM_LOCATION_CONFIG");class MockPlatformLocation{constructor(config){if(this.baseHref="",this.hashUpdate=new Subject.B,this.popStateSubject=new Subject.B,this.urlChangeIndex=0,this.urlChanges=[{hostname:"",protocol:"",port:"",pathname:"/",search:"",hash:"",state:null}],config){this.baseHref=config.appBaseHref||"";const parsedChanges=this.parseChanges(null,config.startUrl||"http://_empty_/",this.baseHref);this.urlChanges[0]={...parsedChanges}}}get hostname(){return this.urlChanges[this.urlChangeIndex].hostname}get protocol(){return this.urlChanges[this.urlChangeIndex].protocol}get port(){return this.urlChanges[this.urlChangeIndex].port}get pathname(){return this.urlChanges[this.urlChangeIndex].pathname}get search(){return this.urlChanges[this.urlChangeIndex].search}get hash(){return this.urlChanges[this.urlChangeIndex].hash}get state(){return this.urlChanges[this.urlChangeIndex].state}getBaseHrefFromDOM(){return this.baseHref}onPopState(fn){const subscription=this.popStateSubject.subscribe(fn);return()=>subscription.unsubscribe()}onHashChange(fn){const subscription=this.hashUpdate.subscribe(fn);return()=>subscription.unsubscribe()}get href(){let url=`${this.protocol}//${this.hostname}${this.port?":"+this.port:""}`;return url+=`${"/"===this.pathname?"":this.pathname}${this.search}${this.hash}`,url}get url(){return`${this.pathname}${this.search}${this.hash}`}parseChanges(state,url,baseHref=""){return state=JSON.parse(JSON.stringify(state)),{...parseUrl(url,baseHref),state}}replaceState(state,title,newUrl){const{pathname,search,state:parsedState,hash}=this.parseChanges(state,newUrl);this.urlChanges[this.urlChangeIndex]={...this.urlChanges[this.urlChangeIndex],pathname,search,hash,state:parsedState}}pushState(state,title,newUrl){const{pathname,search,state:parsedState,hash}=this.parseChanges(state,newUrl);this.urlChangeIndex>0&&this.urlChanges.splice(this.urlChangeIndex+1),this.urlChanges.push({...this.urlChanges[this.urlChangeIndex],pathname,search,hash,state:parsedState}),this.urlChangeIndex=this.urlChanges.length-1}forward(){const oldUrl=this.url,oldHash=this.hash;this.urlChangeIndex<this.urlChanges.length&&this.urlChangeIndex++,this.emitEvents(oldHash,oldUrl)}back(){const oldUrl=this.url,oldHash=this.hash;this.urlChangeIndex>0&&this.urlChangeIndex--,this.emitEvents(oldHash,oldUrl)}historyGo(relativePosition=0){const oldUrl=this.url,oldHash=this.hash,nextPageIndex=this.urlChangeIndex+relativePosition;nextPageIndex>=0&&nextPageIndex<this.urlChanges.length&&(this.urlChangeIndex=nextPageIndex),this.emitEvents(oldHash,oldUrl)}getState(){return this.state}emitEvents(oldHash,oldUrl){this.popStateSubject.next({type:"popstate",state:this.getState(),oldUrl,newUrl:this.url}),oldHash!==this.hash&&this.hashUpdate.next({type:"hashchange",state:null,oldUrl,newUrl:this.url})}static#_=this.ɵfac=function MockPlatformLocation_Factory(t){return new(t||MockPlatformLocation)(core["ɵɵinject"](MOCK_PLATFORM_LOCATION_CONFIG,8))};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:MockPlatformLocation,factory:MockPlatformLocation.ɵfac})}function provideLocationMocks(){return[{provide:common.Location,useClass:SpyLocation},{provide:common.LocationStrategy,useClass:MockLocationStrategy}]}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](MockPlatformLocation,[{type:core.Injectable}],(function(){return[{type:void 0,decorators:[{type:core.Inject,args:[MOCK_PLATFORM_LOCATION_CONFIG]},{type:core.Optional}]}]}),null);var fesm2022_router=__webpack_require__("./node_modules/@angular/router/fesm2022/router.mjs"),compiler=__webpack_require__("./node_modules/@angular/compiler/fesm2022/compiler.mjs"),Subscription=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subscription.js"),Observable=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Observable.js"),merge=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/merge.js"),share=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/share.js");class ComponentFixture{constructor(componentRef,ngZone,_autoDetect){this.componentRef=componentRef,this.ngZone=ngZone,this._autoDetect=_autoDetect,this._isStable=!0,this._isDestroyed=!1,this._resolve=null,this._promise=null,this._onUnstableSubscription=null,this._onStableSubscription=null,this._onMicrotaskEmptySubscription=null,this._onErrorSubscription=null,this.changeDetectorRef=componentRef.changeDetectorRef,this.elementRef=componentRef.location,this.debugElement=(0,core.getDebugNode)(this.elementRef.nativeElement),this.componentInstance=componentRef.instance,this.nativeElement=this.elementRef.nativeElement,this.componentRef=componentRef,this.ngZone=ngZone,ngZone&&ngZone.runOutsideAngular((()=>{this._onUnstableSubscription=ngZone.onUnstable.subscribe({next:()=>{this._isStable=!1}}),this._onMicrotaskEmptySubscription=ngZone.onMicrotaskEmpty.subscribe({next:()=>{this._autoDetect&&this.detectChanges(!0)}}),this._onStableSubscription=ngZone.onStable.subscribe({next:()=>{this._isStable=!0,null!==this._promise&&queueMicrotask((()=>{ngZone.hasPendingMacrotasks||null!==this._promise&&(this._resolve(!0),this._resolve=null,this._promise=null)}))}}),this._onErrorSubscription=ngZone.onError.subscribe({next:error=>{throw error}})}))}_tick(checkNoChanges){this.changeDetectorRef.detectChanges(),checkNoChanges&&this.checkNoChanges()}detectChanges(checkNoChanges=!0){null!=this.ngZone?this.ngZone.run((()=>{this._tick(checkNoChanges)})):this._tick(checkNoChanges)}checkNoChanges(){this.changeDetectorRef.checkNoChanges()}autoDetectChanges(autoDetect=!0){if(null==this.ngZone)throw new Error("Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set");this._autoDetect=autoDetect,this.detectChanges()}isStable(){return this._isStable&&!this.ngZone.hasPendingMacrotasks}whenStable(){return this.isStable()?Promise.resolve(!1):(null!==this._promise||(this._promise=new Promise((res=>{this._resolve=res}))),this._promise)}_getRenderer(){return void 0===this._renderer&&(this._renderer=this.componentRef.injector.get(core.RendererFactory2,null)),this._renderer}whenRenderingDone(){const renderer=this._getRenderer();return renderer&&renderer.whenRenderingDone?renderer.whenRenderingDone():this.whenStable()}destroy(){this._isDestroyed||(this.componentRef.destroy(),null!=this._onUnstableSubscription&&(this._onUnstableSubscription.unsubscribe(),this._onUnstableSubscription=null),null!=this._onStableSubscription&&(this._onStableSubscription.unsubscribe(),this._onStableSubscription=null),null!=this._onMicrotaskEmptySubscription&&(this._onMicrotaskEmptySubscription.unsubscribe(),this._onMicrotaskEmptySubscription=null),null!=this._onErrorSubscription&&(this._onErrorSubscription.unsubscribe(),this._onErrorSubscription=null),this._isDestroyed=!0)}}const _Zone="undefined"!=typeof Zone?Zone:null,fakeAsyncTestModule=_Zone&&_Zone[_Zone.__symbol__("fakeAsyncTest")],fakeAsyncTestModuleNotLoadedErrorMessage="zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing";class TestComponentRenderer{insertRootElement(rootElementId){}removeAllRootElements(){}}const ComponentFixtureAutoDetect=new core.InjectionToken("ComponentFixtureAutoDetect"),ComponentFixtureNoNgZone=new core.InjectionToken("ComponentFixtureNoNgZone");function resolveComponentResources(resourceResolver){const componentResolved=[],urlMap=new Map;function cachedResourceResolve(url){let promise=urlMap.get(url);if(!promise){const resp=resourceResolver(url);urlMap.set(url,promise=resp.then(unwrapResponse))}return promise}return componentResourceResolutionQueue.forEach(((component,type)=>{const promises=[];component.templateUrl&&promises.push(cachedResourceResolve(component.templateUrl).then((template=>{component.template=template})));const styleUrls=component.styleUrls,styles=component.styles||(component.styles=[]),styleOffset=component.styles.length;styleUrls&&styleUrls.forEach(((styleUrl,index)=>{styles.push(""),promises.push(cachedResourceResolve(styleUrl).then((style=>{styles[styleOffset+index]=style,styleUrls.splice(styleUrls.indexOf(styleUrl),1),0==styleUrls.length&&(component.styleUrls=void 0)})))}));const fullyResolved=Promise.all(promises).then((()=>function componentDefResolved(type){componentDefPendingResolution.delete(type)}(type)));componentResolved.push(fullyResolved)})),clearResolutionOfComponentResourcesQueue(),Promise.all(componentResolved).then((()=>{}))}let componentResourceResolutionQueue=new Map;const componentDefPendingResolution=new Set;function isComponentDefPendingResolution(type){return componentDefPendingResolution.has(type)}function clearResolutionOfComponentResourcesQueue(){const old=componentResourceResolutionQueue;return componentResourceResolutionQueue=new Map,old}function unwrapResponse(response){return"string"==typeof response?response:response.text()}const _global=globalThis;var FactoryTarget,R3TemplateDependencyKind,ViewEncapsulation$1;function getCompilerFacade(request){const globalNg=_global.ng;if(globalNg&&globalNg.ɵcompilerFacade)return globalNg.ɵcompilerFacade;if("undefined"==typeof ngDevMode||ngDevMode){console.error(`JIT compilation failed for ${request.kind}`,request.type);let message=`The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.\n\n`;throw 1===request.usage?(message+=`The ${request.kind} is part of a library that has been partially compiled.\n`,message+="However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.\n",message+="\n",message+="Ideally, the library is processed using the Angular Linker to become fully AOT compiled.\n"):message+="JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.\n",message+="Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',\n",message+="or manually provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.",new Error(message)}throw new Error("JIT compiler unavailable")}function getClosureSafeProperty(objWithPropertyToExtract){for(let key in objWithPropertyToExtract)if(objWithPropertyToExtract[key]===getClosureSafeProperty)return key;throw Error("Could not find renamed property on target object.")}function stringify(token){if("string"==typeof token)return token;if(Array.isArray(token))return"["+token.map(stringify).join(", ")+"]";if(null==token)return""+token;if(token.overriddenName)return`${token.overriddenName}`;if(token.name)return`${token.name}`;const res=token.toString();if(null==res)return""+res;const newLineIndex=res.indexOf("\n");return-1===newLineIndex?res:res.substring(0,newLineIndex)}function concatStringsWithSpace(before,after){return null==before||""===before?null===after?"":after:null==after||""===after?before:before+" "+after}!function(FactoryTarget){FactoryTarget[FactoryTarget.Directive=0]="Directive",FactoryTarget[FactoryTarget.Component=1]="Component",FactoryTarget[FactoryTarget.Injectable=2]="Injectable",FactoryTarget[FactoryTarget.Pipe=3]="Pipe",FactoryTarget[FactoryTarget.NgModule=4]="NgModule"}(FactoryTarget||(FactoryTarget={})),function(R3TemplateDependencyKind){R3TemplateDependencyKind[R3TemplateDependencyKind.Directive=0]="Directive",R3TemplateDependencyKind[R3TemplateDependencyKind.Pipe=1]="Pipe",R3TemplateDependencyKind[R3TemplateDependencyKind.NgModule=2]="NgModule"}(R3TemplateDependencyKind||(R3TemplateDependencyKind={})),function(ViewEncapsulation){ViewEncapsulation[ViewEncapsulation.Emulated=0]="Emulated",ViewEncapsulation[ViewEncapsulation.None=2]="None",ViewEncapsulation[ViewEncapsulation.ShadowDom=3]="ShadowDom"}(ViewEncapsulation$1||(ViewEncapsulation$1={}));const __forward_ref__=getClosureSafeProperty({__forward_ref__:getClosureSafeProperty});function forwardRef(forwardRefFn){return forwardRefFn.__forward_ref__=forwardRef,forwardRefFn.toString=function(){return stringify(this())},forwardRefFn}function resolveForwardRef(type){return isForwardRef(type)?type():type}function isForwardRef(fn){return"function"==typeof fn&&fn.hasOwnProperty(__forward_ref__)&&fn.__forward_ref__===forwardRef}function ɵɵdefineInjectable(opts){return{token:opts.token,providedIn:opts.providedIn||null,factory:opts.factory,value:void 0}}function ɵɵdefineInjector(options){return{providers:options.providers||[],imports:options.imports||[]}}function getInjectableDef(type){return getOwnDefinition(type,NG_PROV_DEF)||getOwnDefinition(type,NG_INJECTABLE_DEF)}function getOwnDefinition(type,field){return type.hasOwnProperty(field)?type[field]:null}function getInjectorDef(type){return type&&(type.hasOwnProperty(NG_INJ_DEF)||type.hasOwnProperty(NG_INJECTOR_DEF))?type[NG_INJ_DEF]:null}const NG_PROV_DEF=getClosureSafeProperty({ɵprov:getClosureSafeProperty}),NG_INJ_DEF=getClosureSafeProperty({ɵinj:getClosureSafeProperty}),NG_INJECTABLE_DEF=getClosureSafeProperty({ngInjectableDef:getClosureSafeProperty}),NG_INJECTOR_DEF=getClosureSafeProperty({ngInjectorDef:getClosureSafeProperty}),ERROR_DETAILS_PAGE_BASE_URL="https://angular.io/errors";class RuntimeError extends Error{constructor(code,message){super(formatRuntimeError(code,message)),this.code=code}}function formatRuntimeError(code,message){const fullCode=`NG0${Math.abs(code)}`;let errorMessage=`${fullCode}${message?": "+message:""}`;if(ngDevMode&&code<0){const addPeriodSeparator=!errorMessage.match(/[.,;!?\n]$/);errorMessage=`${errorMessage}${addPeriodSeparator?".":""} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`}return errorMessage}const Type=Function;function isType(v){return"function"==typeof v}function assertNumber(actual,msg){"number"!=typeof actual&&throwError(msg,typeof actual,"number","===")}function assertString(actual,msg){"string"!=typeof actual&&throwError(msg,null===actual?"null":typeof actual,"string","===")}function assertFunction(actual,msg){"function"!=typeof actual&&throwError(msg,null===actual?"null":typeof actual,"function","===")}function assertEqual(actual,expected,msg){actual!=expected&&throwError(msg,actual,expected,"==")}function assertNotEqual(actual,expected,msg){actual==expected&&throwError(msg,actual,expected,"!=")}function assertSame(actual,expected,msg){actual!==expected&&throwError(msg,actual,expected,"===")}function assertNotSame(actual,expected,msg){actual===expected&&throwError(msg,actual,expected,"!==")}function assertLessThan(actual,expected,msg){actual<expected||throwError(msg,actual,expected,"<")}function assertGreaterThan(actual,expected,msg){actual>expected||throwError(msg,actual,expected,">")}function assertGreaterThanOrEqual(actual,expected,msg){actual>=expected||throwError(msg,actual,expected,">=")}function assertDefined(actual,msg){null==actual&&throwError(msg,actual,null,"!=")}function throwError(msg,actual,expected,comparison){throw new Error(`ASSERTION ERROR: ${msg}`+(null==comparison?"":` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`))}function assertIndexInRange(arr,index){assertDefined(arr,"Array must be defined.");const maxLen=arr.length;(index<0||index>=maxLen)&&throwError(`Index expected to be less than ${maxLen} but got ${index}`)}function deepForEach(input,fn){input.forEach((value=>Array.isArray(value)?deepForEach(value,fn):fn(value)))}function addToArray(arr,index,value){index>=arr.length?arr.push(value):arr.splice(index,0,value)}function removeFromArray(arr,index){return index>=arr.length-1?arr.pop():arr.splice(index,1)[0]}function newArray(size,value){const list=[];for(let i=0;i<size;i++)list.push(value);return list}function noSideEffects(fn){return{toString:fn}.toString()}const ANNOTATIONS="__annotations__",PARAMETERS="__parameters__",PROP_METADATA="__prop__metadata__";function makeMetadataCtor(props){return function ctor(...args){if(props){const values=props(...args);for(const propName in values)this[propName]=values[propName]}}}function makeParamDecorator(name,props,parentClass){return noSideEffects((()=>{const metaCtor=makeMetadataCtor(props);function ParamDecoratorFactory(...args){if(this instanceof ParamDecoratorFactory)return metaCtor.apply(this,args),this;const annotationInstance=new ParamDecoratorFactory(...args);return ParamDecorator.annotation=annotationInstance,ParamDecorator;function ParamDecorator(cls,unusedKey,index){const parameters=cls.hasOwnProperty(PARAMETERS)?cls[PARAMETERS]:Object.defineProperty(cls,PARAMETERS,{value:[]})[PARAMETERS];for(;parameters.length<=index;)parameters.push(null);return(parameters[index]=parameters[index]||[]).push(annotationInstance),cls}}return parentClass&&(ParamDecoratorFactory.prototype=Object.create(parentClass.prototype)),ParamDecoratorFactory.prototype.ngMetadataName=name,ParamDecoratorFactory.annotationCls=ParamDecoratorFactory,ParamDecoratorFactory}))}const ES5_DELEGATE_CTOR=/^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/,ES2015_INHERITED_CLASS=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/,ES2015_INHERITED_CLASS_WITH_CTOR=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/,ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;class ReflectionCapabilities{constructor(reflect){this._reflect=reflect||_global.Reflect}factory(t){return(...args)=>new t(...args)}_zipTypesAndAnnotations(paramTypes,paramAnnotations){let result;result=newArray(void 0===paramTypes?paramAnnotations.length:paramTypes.length);for(let i=0;i<result.length;i++)void 0===paramTypes?result[i]=[]:paramTypes[i]&&paramTypes[i]!=Object?result[i]=[paramTypes[i]]:result[i]=[],paramAnnotations&&null!=paramAnnotations[i]&&(result[i]=result[i].concat(paramAnnotations[i]));return result}_ownParameters(type,parentCtor){if(function isDelegateCtor(typeStr){return ES5_DELEGATE_CTOR.test(typeStr)||ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr)||ES2015_INHERITED_CLASS.test(typeStr)&&!ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr)}(type.toString()))return null;if(type.parameters&&type.parameters!==parentCtor.parameters)return type.parameters;const tsickleCtorParams=type.ctorParameters;if(tsickleCtorParams&&tsickleCtorParams!==parentCtor.ctorParameters){const ctorParameters="function"==typeof tsickleCtorParams?tsickleCtorParams():tsickleCtorParams,paramTypes=ctorParameters.map((ctorParam=>ctorParam&&ctorParam.type)),paramAnnotations=ctorParameters.map((ctorParam=>ctorParam&&convertTsickleDecoratorIntoMetadata(ctorParam.decorators)));return this._zipTypesAndAnnotations(paramTypes,paramAnnotations)}const paramAnnotations=type.hasOwnProperty(PARAMETERS)&&type[PARAMETERS],paramTypes=this._reflect&&this._reflect.getOwnMetadata&&this._reflect.getOwnMetadata("design:paramtypes",type);return paramTypes||paramAnnotations?this._zipTypesAndAnnotations(paramTypes,paramAnnotations):newArray(type.length)}parameters(type){if(!isType(type))return[];const parentCtor=getParentCtor(type);let parameters=this._ownParameters(type,parentCtor);return parameters||parentCtor===Object||(parameters=this.parameters(parentCtor)),parameters||[]}_ownAnnotations(typeOrFunc,parentCtor){if(typeOrFunc.annotations&&typeOrFunc.annotations!==parentCtor.annotations){let annotations=typeOrFunc.annotations;return"function"==typeof annotations&&annotations.annotations&&(annotations=annotations.annotations),annotations}return typeOrFunc.decorators&&typeOrFunc.decorators!==parentCtor.decorators?convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators):typeOrFunc.hasOwnProperty(ANNOTATIONS)?typeOrFunc[ANNOTATIONS]:null}annotations(typeOrFunc){if(!isType(typeOrFunc))return[];const parentCtor=getParentCtor(typeOrFunc),ownAnnotations=this._ownAnnotations(typeOrFunc,parentCtor)||[];return(parentCtor!==Object?this.annotations(parentCtor):[]).concat(ownAnnotations)}_ownPropMetadata(typeOrFunc,parentCtor){if(typeOrFunc.propMetadata&&typeOrFunc.propMetadata!==parentCtor.propMetadata){let propMetadata=typeOrFunc.propMetadata;return"function"==typeof propMetadata&&propMetadata.propMetadata&&(propMetadata=propMetadata.propMetadata),propMetadata}if(typeOrFunc.propDecorators&&typeOrFunc.propDecorators!==parentCtor.propDecorators){const propDecorators=typeOrFunc.propDecorators,propMetadata={};return Object.keys(propDecorators).forEach((prop=>{propMetadata[prop]=convertTsickleDecoratorIntoMetadata(propDecorators[prop])})),propMetadata}return typeOrFunc.hasOwnProperty(PROP_METADATA)?typeOrFunc[PROP_METADATA]:null}propMetadata(typeOrFunc){if(!isType(typeOrFunc))return{};const parentCtor=getParentCtor(typeOrFunc),propMetadata={};if(parentCtor!==Object){const parentPropMetadata=this.propMetadata(parentCtor);Object.keys(parentPropMetadata).forEach((propName=>{propMetadata[propName]=parentPropMetadata[propName]}))}const ownPropMetadata=this._ownPropMetadata(typeOrFunc,parentCtor);return ownPropMetadata&&Object.keys(ownPropMetadata).forEach((propName=>{const decorators=[];propMetadata.hasOwnProperty(propName)&&decorators.push(...propMetadata[propName]),decorators.push(...ownPropMetadata[propName]),propMetadata[propName]=decorators})),propMetadata}ownPropMetadata(typeOrFunc){return isType(typeOrFunc)&&this._ownPropMetadata(typeOrFunc,getParentCtor(typeOrFunc))||{}}hasLifecycleHook(type,lcProperty){return type instanceof Type&&lcProperty in type.prototype}}function convertTsickleDecoratorIntoMetadata(decoratorInvocations){return decoratorInvocations?decoratorInvocations.map((decoratorInvocation=>new(0,decoratorInvocation.type.annotationCls)(...decoratorInvocation.args?decoratorInvocation.args:[]))):[]}function getParentCtor(ctor){const parentProto=ctor.prototype?Object.getPrototypeOf(ctor.prototype):null;return(parentProto?parentProto.constructor:null)||Object}function initNgDevMode(){return!("undefined"!=typeof ngDevMode&&!ngDevMode)&&("object"!=typeof ngDevMode&&function ngDevModeResetPerfCounters(){const locationString="undefined"!=typeof location?location.toString():"",newCounters={namedConstructors:-1!=locationString.indexOf("ngDevMode=namedConstructors"),firstCreatePass:0,tNode:0,tView:0,rendererCreateTextNode:0,rendererSetText:0,rendererCreateElement:0,rendererAddEventListener:0,rendererSetAttribute:0,rendererRemoveAttribute:0,rendererSetProperty:0,rendererSetClassName:0,rendererAddClass:0,rendererRemoveClass:0,rendererSetStyle:0,rendererRemoveStyle:0,rendererDestroy:0,rendererDestroyNode:0,rendererMoveNode:0,rendererRemoveNode:0,rendererAppendChild:0,rendererInsertBefore:0,rendererCreateComment:0,hydratedNodes:0,hydratedComponents:0,dehydratedViewsRemoved:0,dehydratedViewsCleanupRuns:0,componentsSkippedHydration:0},allowNgDevModeTrue=-1===locationString.indexOf("ngDevMode=false");return _global.ngDevMode=allowNgDevModeTrue&&newCounters,newCounters}(),"undefined"!=typeof ngDevMode&&!!ngDevMode)}class InjectionToken{constructor(_desc,options){this._desc=_desc,this.ngMetadataName="InjectionToken",this.ɵprov=void 0,"number"==typeof options?(("undefined"==typeof ngDevMode||ngDevMode)&&assertLessThan(options,0,"Only negative numbers are supported here"),this.__NG_ELEMENT_ID__=options):void 0!==options&&(this.ɵprov=ɵɵdefineInjectable({token:this,providedIn:options.providedIn||"root",factory:options.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}let _injectorProfilerContext;function getInjectorProfilerContext(){return!ngDevMode&&throwError("getInjectorProfilerContext should never be called in production mode"),_injectorProfilerContext}function setInjectorProfilerContext(context){!ngDevMode&&throwError("setInjectorProfilerContext should never be called in production mode");const previous=_injectorProfilerContext;return _injectorProfilerContext=context,previous}let injectorProfilerCallback=null;function injectorProfiler(event){!ngDevMode&&throwError("Injector profiler should never be called in production mode"),null!=injectorProfilerCallback&&injectorProfilerCallback(event)}function emitProviderConfiguredEvent(eventProvider,isViewProvider=!1){let token;!ngDevMode&&throwError("Injector profiler should never be called in production mode"),token="function"==typeof eventProvider||eventProvider instanceof InjectionToken?eventProvider:resolveForwardRef(eventProvider.provide);let provider=eventProvider;eventProvider instanceof InjectionToken&&(provider=eventProvider.ɵprov||eventProvider),injectorProfiler({type:2,context:getInjectorProfilerContext(),providerRecord:{token,provider,isViewProvider}})}function emitInstanceCreatedByInjectorEvent(instance){!ngDevMode&&throwError("Injector profiler should never be called in production mode"),injectorProfiler({type:1,context:getInjectorProfilerContext(),instance:{value:instance}})}function emitInjectEvent(token,value,flags){!ngDevMode&&throwError("Injector profiler should never be called in production mode"),injectorProfiler({type:0,context:getInjectorProfilerContext(),service:{token,value,flags}})}function runInInjectorProfilerContext(injector,token,callback){!ngDevMode&&throwError("runInInjectorProfilerContext should never be called in production mode");const prevInjectContext=setInjectorProfilerContext({injector,token});try{callback()}finally{setInjectorProfilerContext(prevInjectContext)}}function isEnvironmentProviders(value){return value&&!!value.ɵproviders}function renderStringify(value){return"string"==typeof value?value:null==value?"":String(value)}function stringifyForError(value){return"function"==typeof value?value.name||value.toString():"object"==typeof value&&null!=value&&"function"==typeof value.type?value.type.name||value.type.toString():renderStringify(value)}function throwCyclicDependencyError(token,path){const depPath=path?`. Dependency path: ${path.join(" > ")} > ${token}`:"";throw new RuntimeError(-200,`Circular dependency in DI detected for ${token}${depPath}`)}function throwMixedMultiProviderError(){throw new Error("Cannot mix multi providers and regular providers")}function throwInvalidProviderError(ngModuleType,providers,provider){if(ngModuleType&&providers){const providerDetail=providers.map((v=>v==provider?"?"+provider+"?":"..."));throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(", ")}]`)}throw isEnvironmentProviders(provider)?provider.ɵfromNgModule?new RuntimeError(207,"Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers."):new RuntimeError(207,"Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers."):new Error("Invalid provider")}function throwProviderNotFoundError(token,injectorName){const injectorDetails=injectorName?` in ${injectorName}`:"";throw new RuntimeError(-201,ngDevMode&&`No provider for ${stringifyForError(token)} found${injectorDetails}`)}var InjectFlags;let _injectImplementation;function getInjectImplementation(){return _injectImplementation}function setInjectImplementation(impl){const previous=_injectImplementation;return _injectImplementation=impl,previous}function injectRootLimpMode(token,notFoundValue,flags){const injectableDef=getInjectableDef(token);return injectableDef&&"root"==injectableDef.providedIn?void 0===injectableDef.value?injectableDef.value=injectableDef.factory():injectableDef.value:flags&InjectFlags.Optional?null:void 0!==notFoundValue?notFoundValue:void throwProviderNotFoundError(stringify(token),"Injector")}!function(InjectFlags){InjectFlags[InjectFlags.Default=0]="Default",InjectFlags[InjectFlags.Host=1]="Host",InjectFlags[InjectFlags.Self=2]="Self",InjectFlags[InjectFlags.SkipSelf=4]="SkipSelf",InjectFlags[InjectFlags.Optional=8]="Optional"}(InjectFlags||(InjectFlags={}));const THROW_IF_NOT_FOUND={},DI_DECORATOR_FLAG="__NG_DI_FLAG__",NEW_LINE=/\n/gm,NO_NEW_LINE="ɵ";let _currentInjector;function setCurrentInjector(injector){const former=_currentInjector;return _currentInjector=injector,former}function injectInjectorOnly(token,flags=InjectFlags.Default){if(void 0===_currentInjector)throw new RuntimeError(-203,ngDevMode&&"inject() must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`.");if(null===_currentInjector)return injectRootLimpMode(token,void 0,flags);{const value=_currentInjector.get(token,flags&InjectFlags.Optional?null:void 0,flags);return ngDevMode&&emitInjectEvent(token,value,flags),value}}function ɵɵinject(token,flags=InjectFlags.Default){return(getInjectImplementation()||injectInjectorOnly)(resolveForwardRef(token),flags)}function ɵɵinvalidFactoryDep(index){throw new RuntimeError(202,ngDevMode&&`This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`)}function inject$1(token,flags=InjectFlags.Default){return ɵɵinject(token,convertToBitFlags(flags))}function convertToBitFlags(flags){return void 0===flags||"number"==typeof flags?flags:(flags.optional&&8)|(flags.host&&1)|(flags.self&&2)|(flags.skipSelf&&4)}function injectArgs(types){const args=[];for(let i=0;i<types.length;i++){const arg=resolveForwardRef(types[i]);if(Array.isArray(arg)){if(0===arg.length)throw new RuntimeError(900,ngDevMode&&"Arguments array must have arguments.");let type,flags=InjectFlags.Default;for(let j=0;j<arg.length;j++){const meta=arg[j],flag=meta[DI_DECORATOR_FLAG];"number"==typeof flag?-1===flag?type=meta.token:flags|=flag:type=meta}args.push(ɵɵinject(type,flags))}else args.push(ɵɵinject(arg))}return args}function attachInjectFlag(decorator,flag){return decorator[DI_DECORATOR_FLAG]=flag,decorator.prototype[DI_DECORATOR_FLAG]=flag,decorator}function catchInjectorError(e,token,injectorErrorName,source){const tokenPath=e.ngTempTokenPath;throw token.__source&&tokenPath.unshift(token.__source),e.message=function formatError(text,obj,injectorErrorName,source=null){text=text&&"\n"===text.charAt(0)&&text.charAt(1)==NO_NEW_LINE?text.slice(2):text;let context=stringify(obj);if(Array.isArray(obj))context=obj.map(stringify).join(" -> ");else if("object"==typeof obj){let parts=[];for(let key in obj)if(obj.hasOwnProperty(key)){let value=obj[key];parts.push(key+":"+("string"==typeof value?JSON.stringify(value):stringify(value)))}context=`{${parts.join(", ")}}`}return`${injectorErrorName}${source?"("+source+")":""}[${context}]: ${text.replace(NEW_LINE,"\n  ")}`}("\n"+e.message,tokenPath,injectorErrorName,source),e.ngTokenPath=tokenPath,e.ngTempTokenPath=null,e}const Inject=attachInjectFlag(makeParamDecorator("Inject",(token=>({token}))),-1),Optional=attachInjectFlag(makeParamDecorator("Optional"),8),Self=attachInjectFlag(makeParamDecorator("Self"),2),SkipSelf=attachInjectFlag(makeParamDecorator("SkipSelf"),4),Host=attachInjectFlag(makeParamDecorator("Host"),1);var ChangeDetectionStrategy,ViewEncapsulation;!function(ChangeDetectionStrategy){ChangeDetectionStrategy[ChangeDetectionStrategy.OnPush=0]="OnPush",ChangeDetectionStrategy[ChangeDetectionStrategy.Default=1]="Default"}(ChangeDetectionStrategy||(ChangeDetectionStrategy={})),function(ViewEncapsulation){ViewEncapsulation[ViewEncapsulation.Emulated=0]="Emulated",ViewEncapsulation[ViewEncapsulation.None=2]="None",ViewEncapsulation[ViewEncapsulation.ShadowDom=3]="ShadowDom"}(ViewEncapsulation||(ViewEncapsulation={}));const EMPTY_OBJ={},EMPTY_ARRAY=[];("undefined"==typeof ngDevMode||ngDevMode)&&initNgDevMode()&&(Object.freeze(EMPTY_OBJ),Object.freeze(EMPTY_ARRAY));const NG_COMP_DEF=getClosureSafeProperty({ɵcmp:getClosureSafeProperty}),NG_FACTORY_DEF=(getClosureSafeProperty({ɵdir:getClosureSafeProperty}),getClosureSafeProperty({ɵpipe:getClosureSafeProperty}),getClosureSafeProperty({ɵmod:getClosureSafeProperty}),getClosureSafeProperty({ɵfac:getClosureSafeProperty})),NG_ELEMENT_ID=getClosureSafeProperty({__NG_ELEMENT_ID__:getClosureSafeProperty}),NG_ENV_ID=getClosureSafeProperty({__NG_ENV_ID__:getClosureSafeProperty});function setUpAttributes(renderer,native,attrs){let i=0;for(;i<attrs.length;){const value=attrs[i];if("number"==typeof value){if(0!==value)break;i++;const namespaceURI=attrs[i++],attrName=attrs[i++],attrVal=attrs[i++];ngDevMode&&ngDevMode.rendererSetAttribute++,renderer.setAttribute(native,attrName,attrVal,namespaceURI)}else{const attrName=value,attrVal=attrs[++i];ngDevMode&&ngDevMode.rendererSetAttribute++,isAnimationProp(attrName)?renderer.setProperty(native,attrName,attrVal):renderer.setAttribute(native,attrName,attrVal),i++}}return i}function isNameOnlyAttributeMarker(marker){return 3===marker||4===marker||6===marker}function isAnimationProp(name){return 64===name.charCodeAt(0)}function mergeHostAttrs(dst,src){if(null===src||0===src.length);else if(null===dst||0===dst.length)dst=src.slice();else{let srcMarker=-1;for(let i=0;i<src.length;i++){const item=src[i];"number"==typeof item?srcMarker=item:0===srcMarker||mergeHostAttribute(dst,srcMarker,item,null,-1===srcMarker||2===srcMarker?src[++i]:null)}}return dst}function mergeHostAttribute(dst,marker,key1,key2,value){let i=0,markerInsertPosition=dst.length;if(-1===marker)markerInsertPosition=-1;else for(;i<dst.length;){const dstValue=dst[i++];if("number"==typeof dstValue){if(dstValue===marker){markerInsertPosition=-1;break}if(dstValue>marker){markerInsertPosition=i-1;break}}}for(;i<dst.length;){const item=dst[i];if("number"==typeof item)break;if(item===key1){if(null===key2)return void(null!==value&&(dst[i+1]=value));if(key2===dst[i+1])return void(dst[i+2]=value)}i++,null!==key2&&i++,null!==value&&i++}-1!==markerInsertPosition&&(dst.splice(markerInsertPosition,0,marker),i=markerInsertPosition+1),dst.splice(i++,0,key1),null!==key2&&dst.splice(i++,0,key2),null!==value&&dst.splice(i++,0,value)}const NG_TEMPLATE_SELECTOR="ng-template";function isInlineTemplate(tNode){return 4===tNode.type&&tNode.value!==NG_TEMPLATE_SELECTOR}function isPositive(mode){return!(1&mode)}function maybeWrapInNotSelector(isNegativeMode,chunk){return isNegativeMode?":not("+chunk.trim()+")":chunk}function stringifyCSSSelector(selector){let result=selector[0],i=1,mode=2,currentChunk="",isNegativeMode=!1;for(;i<selector.length;){let valueOrMarker=selector[i];if("string"==typeof valueOrMarker)if(2&mode){const attrValue=selector[++i];currentChunk+="["+valueOrMarker+(attrValue.length>0?'="'+attrValue+'"':"")+"]"}else 8&mode?currentChunk+="."+valueOrMarker:4&mode&&(currentChunk+=" "+valueOrMarker);else""===currentChunk||isPositive(valueOrMarker)||(result+=maybeWrapInNotSelector(isNegativeMode,currentChunk),currentChunk=""),mode=valueOrMarker,isNegativeMode=isNegativeMode||!isPositive(mode);i++}return""!==currentChunk&&(result+=maybeWrapInNotSelector(isNegativeMode,currentChunk)),result}function stringifyCSSSelectorList(selectorList){return selectorList.map(stringifyCSSSelector).join(",")}function getComponentDef$1(type){return type[NG_COMP_DEF]||null}new Map;const HOST=0,TVIEW=1,FLAGS=2,PARENT=3,NEXT=4,DESCENDANT_VIEWS_TO_REFRESH=5,T_HOST=6,CLEANUP=7,CONTEXT=8,INJECTOR$1=9,ENVIRONMENT=10,RENDERER=11,CHILD_HEAD=12,CHILD_TAIL=13,DECLARATION_VIEW=14,DECLARATION_COMPONENT_VIEW=15,DECLARATION_LCONTAINER=16,PREORDER_HOOK_FLAGS=17,QUERIES=18,ID=19,EMBEDDED_VIEW_INJECTOR=20,ON_DESTROY_HOOKS=21,HYDRATION=22,REACTIVE_TEMPLATE_CONSUMER=23,REACTIVE_HOST_BINDING_CONSUMER=24,HEADER_OFFSET=25,TYPE=1,HAS_TRANSPLANTED_VIEWS=2,NATIVE=7,MOVED_VIEWS=9,CONTAINER_HEADER_OFFSET=11;function isLView(value){return Array.isArray(value)&&"object"==typeof value[TYPE]}function isLContainer(value){return Array.isArray(value)&&!0===value[TYPE]}function isContentQueryHost(tNode){return!!(4&tNode.flags)}function isComponentHost(tNode){return tNode.componentOffset>-1}function isComponentDef(def){return!!def.template}function isRootView(target){return!!(512&target[FLAGS])}function assertTNodeForLView(tNode,lView){assertTNodeForTView(tNode,lView[TVIEW])}function assertTNodeForTView(tNode,tView){assertTNode(tNode);const tData=tView.data;for(let i=HEADER_OFFSET;i<tData.length;i++)if(tData[i]===tNode)return;throwError("This TNode does not belong to this TView.")}function assertTNode(tNode){assertDefined(tNode,"TNode must be defined"),tNode&&"object"==typeof tNode&&tNode.hasOwnProperty("directiveStylingLast")||throwError("Not of type TNode, got: "+tNode)}function assertLContainer(value){assertDefined(value,"LContainer must be defined"),assertEqual(isLContainer(value),!0,"Expecting LContainer")}function assertLViewOrUndefined(value){value&&assertEqual(isLView(value),!0,"Expecting LView or undefined or null")}function assertLView(value){assertDefined(value,"LView must be defined"),assertEqual(isLView(value),!0,"Expecting LView")}function assertFirstCreatePass(tView,errMessage){assertEqual(tView.firstCreatePass,!0,errMessage||"Should only be called in first create pass.")}function assertFirstUpdatePass(tView,errMessage){assertEqual(tView.firstUpdatePass,!0,errMessage||"Should only be called in first update pass.")}function assertIndexInExpandoRange(lView,index){assertBetween(lView[1].expandoStartIndex,lView.length,index)}function assertBetween(lower,upper,index){lower<=index&&index<upper||throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`)}function assertParentView(lView,errMessage){assertDefined(lView,errMessage||"Component views should always have a parent view (component's host view)")}function assertNodeInjector(lView,injectorIndex){assertIndexInExpandoRange(lView,injectorIndex),assertIndexInExpandoRange(lView,injectorIndex+8),assertNumber(lView[injectorIndex+0],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+1],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+2],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+3],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+4],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+5],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+6],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+7],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+8],"injectorIndex should point to parent injector")}function getFactoryDef(type,throwNotFound){const hasFactoryDef=type.hasOwnProperty(NG_FACTORY_DEF);if(!hasFactoryDef&&!0===throwNotFound&&ngDevMode)throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);return hasFactoryDef?type[NG_FACTORY_DEF]:null}let activeConsumer=null,inNotificationPhase=!1;function setActiveConsumer(consumer){const prev=activeConsumer;return activeConsumer=consumer,prev}const REACTIVE_NODE={version:0,dirty:!1,producerNode:void 0,producerLastReadVersion:void 0,producerIndexOfThis:void 0,nextProducerIndex:0,liveConsumerNode:void 0,liveConsumerIndexOfThis:void 0,consumerAllowSignalWrites:!1,consumerIsAlwaysLive:!1,producerMustRecompute:()=>!1,producerRecomputeValue:()=>{},consumerMarkedDirty:()=>{}};function producerUpdateValueVersion(node){consumerIsLive(node)&&!node.dirty||(node.producerMustRecompute(node)||consumerPollProducersForChange(node)?(node.producerRecomputeValue(node),node.dirty=!1):node.dirty=!1)}function producerNotifyConsumers(node){if(void 0===node.liveConsumerNode)return;const prev=inNotificationPhase;inNotificationPhase=!0;try{for(const consumer of node.liveConsumerNode)consumer.dirty||consumerMarkDirty(consumer)}finally{inNotificationPhase=prev}}function consumerMarkDirty(node){node.dirty=!0,producerNotifyConsumers(node),node.consumerMarkedDirty?.(node)}function consumerBeforeComputation(node){return node&&(node.nextProducerIndex=0),setActiveConsumer(node)}function consumerAfterComputation(node,prevConsumer){if(setActiveConsumer(prevConsumer),node&&void 0!==node.producerNode&&void 0!==node.producerIndexOfThis&&void 0!==node.producerLastReadVersion){if(consumerIsLive(node))for(let i=node.nextProducerIndex;i<node.producerNode.length;i++)producerRemoveLiveConsumerAtIndex(node.producerNode[i],node.producerIndexOfThis[i]);for(;node.producerNode.length>node.nextProducerIndex;)node.producerNode.pop(),node.producerLastReadVersion.pop(),node.producerIndexOfThis.pop()}}function consumerPollProducersForChange(node){assertConsumerNode(node);for(let i=0;i<node.producerNode.length;i++){const producer=node.producerNode[i],seenVersion=node.producerLastReadVersion[i];if(seenVersion!==producer.version)return!0;if(producerUpdateValueVersion(producer),seenVersion!==producer.version)return!0}return!1}function consumerDestroy(node){if(assertConsumerNode(node),consumerIsLive(node))for(let i=0;i<node.producerNode.length;i++)producerRemoveLiveConsumerAtIndex(node.producerNode[i],node.producerIndexOfThis[i]);node.producerNode.length=node.producerLastReadVersion.length=node.producerIndexOfThis.length=0,node.liveConsumerNode&&(node.liveConsumerNode.length=node.liveConsumerIndexOfThis.length=0)}function producerRemoveLiveConsumerAtIndex(node,idx){if(assertProducerNode(node),assertConsumerNode(node),"undefined"!=typeof ngDevMode&&ngDevMode&&idx>=node.liveConsumerNode.length)throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);if(1===node.liveConsumerNode.length)for(let i=0;i<node.producerNode.length;i++)producerRemoveLiveConsumerAtIndex(node.producerNode[i],node.producerIndexOfThis[i]);const lastIdx=node.liveConsumerNode.length-1;if(node.liveConsumerNode[idx]=node.liveConsumerNode[lastIdx],node.liveConsumerIndexOfThis[idx]=node.liveConsumerIndexOfThis[lastIdx],node.liveConsumerNode.length--,node.liveConsumerIndexOfThis.length--,idx<node.liveConsumerNode.length){const idxProducer=node.liveConsumerIndexOfThis[idx],consumer=node.liveConsumerNode[idx];assertConsumerNode(consumer),consumer.producerIndexOfThis[idxProducer]=idx}}function consumerIsLive(node){return node.consumerIsAlwaysLive||(node?.liveConsumerNode?.length??0)>0}function assertConsumerNode(node){node.producerNode??=[],node.producerIndexOfThis??=[],node.producerLastReadVersion??=[]}function assertProducerNode(node){node.liveConsumerNode??=[],node.liveConsumerIndexOfThis??=[]}const NOOP_CLEANUP_FN=()=>{},WATCH_NODE=(()=>({...REACTIVE_NODE,consumerIsAlwaysLive:!0,consumerAllowSignalWrites:!1,consumerMarkedDirty:node=>{node.schedule(node.ref)},hasRun:!1,cleanupFn:NOOP_CLEANUP_FN}))();class SimpleChange{constructor(previousValue,currentValue,firstChange){this.previousValue=previousValue,this.currentValue=currentValue,this.firstChange=firstChange}isFirstChange(){return this.firstChange}}function ɵɵNgOnChangesFeature(){return NgOnChangesFeatureImpl}function NgOnChangesFeatureImpl(definition){return definition.type.prototype.ngOnChanges&&(definition.setInput=ngOnChangesSetInput),rememberChangeHistoryAndInvokeOnChangesHook}function rememberChangeHistoryAndInvokeOnChangesHook(){const simpleChangesStore=getSimpleChangesStore(this),current=simpleChangesStore?.current;if(current){const previous=simpleChangesStore.previous;if(previous===EMPTY_OBJ)simpleChangesStore.previous=current;else for(let key in current)previous[key]=current[key];simpleChangesStore.current=null,this.ngOnChanges(current)}}function ngOnChangesSetInput(instance,value,publicName,privateName){const declaredName=this.declaredInputs[publicName];ngDevMode&&assertString(declaredName,"Name of input in ngOnChanges has to be a string");const simpleChangesStore=getSimpleChangesStore(instance)||function setSimpleChangesStore(instance,store){return instance[SIMPLE_CHANGES_STORE]=store}(instance,{previous:EMPTY_OBJ,current:null}),current=simpleChangesStore.current||(simpleChangesStore.current={}),previous=simpleChangesStore.previous,previousChange=previous[declaredName];current[declaredName]=new SimpleChange(previousChange&&previousChange.currentValue,value,previous===EMPTY_OBJ),instance[privateName]=value}ɵɵNgOnChangesFeature.ngInherit=!0;const SIMPLE_CHANGES_STORE="__ngSimpleChanges__";function getSimpleChangesStore(instance){return instance[SIMPLE_CHANGES_STORE]||null}let profilerCallback=null;const profiler=function(event,instance,hookOrListener){null!=profilerCallback&&profilerCallback(event,instance,hookOrListener)};function unwrapRNode(value){for(;Array.isArray(value);)value=value[HOST];return value}function getNativeByTNode(tNode,lView){ngDevMode&&assertTNodeForLView(tNode,lView),ngDevMode&&assertIndexInRange(lView,tNode.index);return unwrapRNode(lView[tNode.index])}function getTNode(tView,index){ngDevMode&&assertGreaterThan(index,-1,"wrong index for TNode"),ngDevMode&&assertLessThan(index,tView.data.length,"wrong index for TNode");const tNode=tView.data[index];return ngDevMode&&null!==tNode&&assertTNode(tNode),tNode}function getComponentLViewByIndex(nodeIndex,hostView){ngDevMode&&assertIndexInRange(hostView,nodeIndex);const slotValue=hostView[nodeIndex];return isLView(slotValue)?slotValue:slotValue[HOST]}function isCreationMode(view){return!(4&~view[FLAGS])}function resetPreOrderHookFlags(lView){lView[PREORDER_HOOK_FLAGS]=0}function markViewForRefresh(lView){1024&lView[FLAGS]||(lView[FLAGS]|=1024,updateViewsToRefresh(lView,1))}function clearViewRefreshFlag(lView){1024&lView[FLAGS]&&(lView[FLAGS]&=-1025,updateViewsToRefresh(lView,-1))}function updateViewsToRefresh(lView,amount){let parent=lView[PARENT];if(null===parent)return;parent[DESCENDANT_VIEWS_TO_REFRESH]+=amount;let viewOrContainer=parent;for(parent=parent[PARENT];null!==parent&&(1===amount&&1===viewOrContainer[DESCENDANT_VIEWS_TO_REFRESH]||-1===amount&&0===viewOrContainer[DESCENDANT_VIEWS_TO_REFRESH]);)parent[DESCENDANT_VIEWS_TO_REFRESH]+=amount,viewOrContainer=parent,parent=parent[PARENT]}function storeLViewOnDestroy(lView,onDestroyCallback){if(!(256&~lView[FLAGS]))throw new RuntimeError(911,ngDevMode&&"View has already been destroyed.");null===lView[ON_DESTROY_HOOKS]&&(lView[ON_DESTROY_HOOKS]=[]),lView[ON_DESTROY_HOOKS].push(onDestroyCallback)}const instructionState={lFrame:createLFrame(null),bindingsEnabled:!0,skipHydrationRootTNode:null};let _isInCheckNoChangesMode=!1;function isInSkipHydrationBlock$1(){return null!==instructionState.skipHydrationRootTNode}function getLView(){return instructionState.lFrame.lView}function getTView(){return instructionState.lFrame.tView}function getCurrentTNode(){let currentTNode=getCurrentTNodePlaceholderOk();for(;null!==currentTNode&&64===currentTNode.type;)currentTNode=currentTNode.parent;return currentTNode}function getCurrentTNodePlaceholderOk(){return instructionState.lFrame.currentTNode}function getCurrentParentTNode(){const lFrame=instructionState.lFrame,currentTNode=lFrame.currentTNode;return lFrame.isParent?currentTNode:currentTNode.parent}function setCurrentTNode(tNode,isParent){ngDevMode&&tNode&&assertTNodeForTView(tNode,instructionState.lFrame.tView);const lFrame=instructionState.lFrame;lFrame.currentTNode=tNode,lFrame.isParent=isParent}function isCurrentTNodeParent(){return instructionState.lFrame.isParent}function isInCheckNoChangesMode(){return!ngDevMode&&throwError("Must never be called in production mode"),_isInCheckNoChangesMode}function setIsInCheckNoChangesMode(mode){!ngDevMode&&throwError("Must never be called in production mode"),_isInCheckNoChangesMode=mode}function setBindingIndex(value){return instructionState.lFrame.bindingIndex=value}function setBindingRootForHostBindings(bindingRootIndex,currentDirectiveIndex){const lFrame=instructionState.lFrame;lFrame.bindingIndex=lFrame.bindingRootIndex=bindingRootIndex,setCurrentDirectiveIndex(currentDirectiveIndex)}function setCurrentDirectiveIndex(currentDirectiveIndex){instructionState.lFrame.currentDirectiveIndex=currentDirectiveIndex}function setCurrentQueryIndex(value){instructionState.lFrame.currentQueryIndex=value}function getDeclarationTNode(lView){const tView=lView[TVIEW];return 2===tView.type?(ngDevMode&&assertDefined(tView.declTNode,"Embedded TNodes should have declaration parents."),tView.declTNode):1===tView.type?lView[T_HOST]:null}function enterDI(lView,tNode,flags){if(ngDevMode&&assertLViewOrUndefined(lView),flags&InjectFlags.SkipSelf){ngDevMode&&assertTNodeForTView(tNode,lView[TVIEW]);let parentTNode=tNode,parentLView=lView;for(;!(ngDevMode&&assertDefined(parentTNode,"Parent TNode should be defined"),parentTNode=parentTNode.parent,null!==parentTNode||flags&InjectFlags.Host||(parentTNode=getDeclarationTNode(parentLView),null===parentTNode)||(ngDevMode&&assertDefined(parentLView,"Parent LView should be defined"),parentLView=parentLView[DECLARATION_VIEW],10&parentTNode.type)););if(null===parentTNode)return!1;tNode=parentTNode,lView=parentLView}ngDevMode&&assertTNodeForLView(tNode,lView);const lFrame=instructionState.lFrame=allocLFrame();return lFrame.currentTNode=tNode,lFrame.lView=lView,!0}function enterView(newView){ngDevMode&&assertNotEqual(newView[0],newView[1],"????"),ngDevMode&&assertLViewOrUndefined(newView);const newLFrame=allocLFrame();ngDevMode&&(assertEqual(newLFrame.isParent,!0,"Expected clean LFrame"),assertEqual(newLFrame.lView,null,"Expected clean LFrame"),assertEqual(newLFrame.tView,null,"Expected clean LFrame"),assertEqual(newLFrame.selectedIndex,-1,"Expected clean LFrame"),assertEqual(newLFrame.elementDepthCount,0,"Expected clean LFrame"),assertEqual(newLFrame.currentDirectiveIndex,-1,"Expected clean LFrame"),assertEqual(newLFrame.currentNamespace,null,"Expected clean LFrame"),assertEqual(newLFrame.bindingRootIndex,-1,"Expected clean LFrame"),assertEqual(newLFrame.currentQueryIndex,0,"Expected clean LFrame"));const tView=newView[TVIEW];instructionState.lFrame=newLFrame,ngDevMode&&tView.firstChild&&assertTNodeForTView(tView.firstChild,tView),newLFrame.currentTNode=tView.firstChild,newLFrame.lView=newView,newLFrame.tView=tView,newLFrame.contextLView=newView,newLFrame.bindingIndex=tView.bindingStartIndex,newLFrame.inI18n=!1}function allocLFrame(){const currentLFrame=instructionState.lFrame,childLFrame=null===currentLFrame?null:currentLFrame.child;return null===childLFrame?createLFrame(currentLFrame):childLFrame}function createLFrame(parent){const lFrame={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent,child:null,inI18n:!1};return null!==parent&&(parent.child=lFrame),lFrame}function leaveViewLight(){const oldLFrame=instructionState.lFrame;return instructionState.lFrame=oldLFrame.parent,oldLFrame.currentTNode=null,oldLFrame.lView=null,oldLFrame}const leaveDI=leaveViewLight;function leaveView(){const oldLFrame=leaveViewLight();oldLFrame.isParent=!0,oldLFrame.tView=null,oldLFrame.selectedIndex=-1,oldLFrame.contextLView=null,oldLFrame.elementDepthCount=0,oldLFrame.currentDirectiveIndex=-1,oldLFrame.currentNamespace=null,oldLFrame.bindingRootIndex=-1,oldLFrame.bindingIndex=-1,oldLFrame.currentQueryIndex=0}function getSelectedIndex(){return instructionState.lFrame.selectedIndex}function setSelectedIndex(index){ngDevMode&&-1!==index&&assertGreaterThanOrEqual(index,HEADER_OFFSET,"Index must be past HEADER_OFFSET (or -1)."),ngDevMode&&assertLessThan(index,instructionState.lFrame.lView.length,"Can't set index passed end of LView"),instructionState.lFrame.selectedIndex=index}function registerPostOrderHooks(tView,tNode){ngDevMode&&assertFirstCreatePass(tView);for(let i=tNode.directiveStart,end=tNode.directiveEnd;i<end;i++){const directiveDef=tView.data[i];ngDevMode&&assertDefined(directiveDef,"Expecting DirectiveDef");const lifecycleHooks=directiveDef.type.prototype,{ngAfterContentInit,ngAfterContentChecked,ngAfterViewInit,ngAfterViewChecked,ngOnDestroy}=lifecycleHooks;ngAfterContentInit&&(tView.contentHooks??=[]).push(-i,ngAfterContentInit),ngAfterContentChecked&&((tView.contentHooks??=[]).push(i,ngAfterContentChecked),(tView.contentCheckHooks??=[]).push(i,ngAfterContentChecked)),ngAfterViewInit&&(tView.viewHooks??=[]).push(-i,ngAfterViewInit),ngAfterViewChecked&&((tView.viewHooks??=[]).push(i,ngAfterViewChecked),(tView.viewCheckHooks??=[]).push(i,ngAfterViewChecked)),null!=ngOnDestroy&&(tView.destroyHooks??=[]).push(i,ngOnDestroy)}}function executeCheckHooks(lView,hooks,nodeIndex){callHooks(lView,hooks,3,nodeIndex)}function executeInitAndCheckHooks(lView,hooks,initPhase,nodeIndex){ngDevMode&&assertNotEqual(initPhase,3,"Init pre-order hooks should not be called more than once"),(3&lView[FLAGS])===initPhase&&callHooks(lView,hooks,initPhase,nodeIndex)}function incrementInitPhaseFlags(lView,initPhase){ngDevMode&&assertNotEqual(initPhase,3,"Init hooks phase should not be incremented after all init hooks have been run.");let flags=lView[FLAGS];(3&flags)===initPhase&&(flags&=8191,flags+=1,lView[FLAGS]=flags)}function callHooks(currentView,arr,initPhase,currentNodeIndex){ngDevMode&&assertEqual(isInCheckNoChangesMode(),!1,"Hooks should never be run when in check no changes mode.");const startIndex=void 0!==currentNodeIndex?65535&currentView[PREORDER_HOOK_FLAGS]:0,nodeIndexLimit=null!=currentNodeIndex?currentNodeIndex:-1,max=arr.length-1;let lastNodeIndexFound=0;for(let i=startIndex;i<max;i++){if("number"==typeof arr[i+1]){if(lastNodeIndexFound=arr[i],null!=currentNodeIndex&&lastNodeIndexFound>=currentNodeIndex)break}else{arr[i]<0&&(currentView[PREORDER_HOOK_FLAGS]+=65536),(lastNodeIndexFound<nodeIndexLimit||-1==nodeIndexLimit)&&(callHook(currentView,initPhase,arr,i),currentView[PREORDER_HOOK_FLAGS]=(4294901760&currentView[PREORDER_HOOK_FLAGS])+i+2),i++}}}function callHookInternal(directive,hook){profiler(4,directive,hook);const prevConsumer=setActiveConsumer(null);try{hook.call(directive)}finally{setActiveConsumer(prevConsumer),profiler(5,directive,hook)}}function callHook(currentView,initPhase,arr,i){const isInitHook=arr[i]<0,hook=arr[i+1],directive=currentView[isInitHook?-arr[i]:arr[i]];if(isInitHook){currentView[FLAGS]>>13<currentView[PREORDER_HOOK_FLAGS]>>16&&(3&currentView[FLAGS])===initPhase&&(currentView[FLAGS]+=8192,callHookInternal(directive,hook))}else callHookInternal(directive,hook)}const NO_PARENT_INJECTOR=-1;class NodeInjectorFactory{constructor(factory,isViewProvider,injectImplementation){this.factory=factory,this.resolving=!1,ngDevMode&&assertDefined(factory,"Factory not specified"),ngDevMode&&assertEqual(typeof factory,"function","Expected factory function."),this.canSeeViewProviders=isViewProvider,this.injectImpl=injectImplementation}}function toTNodeTypeAsString(tNodeType){let text="";return 1&tNodeType&&(text+="|Text"),2&tNodeType&&(text+="|Element"),4&tNodeType&&(text+="|Container"),8&tNodeType&&(text+="|ElementContainer"),16&tNodeType&&(text+="|Projection"),32&tNodeType&&(text+="|IcuContainer"),64&tNodeType&&(text+="|Placeholder"),text.length>0?text.substring(1):text}function assertTNodeType(tNode,expectedTypes,message){assertDefined(tNode,"should be called with a TNode"),tNode.type&expectedTypes||throwError(message||`Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`)}function hasParentInjector(parentLocation){return parentLocation!==NO_PARENT_INJECTOR}function getParentInjectorIndex(parentLocation){ngDevMode&&assertNumber(parentLocation,"Number expected"),ngDevMode&&assertNotEqual(parentLocation,-1,"Not a valid state.");return ngDevMode&&assertGreaterThan(32767&parentLocation,HEADER_OFFSET,"Parent injector must be pointing past HEADER_OFFSET."),32767&parentLocation}function getParentInjectorView(location,startView){let viewOffset=function getParentInjectorViewOffset(parentLocation){return parentLocation>>16}(location),parentView=startView;for(;viewOffset>0;)parentView=parentView[DECLARATION_VIEW],viewOffset--;return parentView}let includeViewProviders=!0;function setIncludeViewProviders(v){const oldValue=includeViewProviders;return includeViewProviders=v,oldValue}const BLOOM_MASK=255,BLOOM_BUCKET_BITS=5;let nextNgElementId=0;const NOT_FOUND={};function getOrCreateNodeInjectorForNode(tNode,lView){const existingInjectorIndex=getInjectorIndex(tNode,lView);if(-1!==existingInjectorIndex)return existingInjectorIndex;const tView=lView[TVIEW];tView.firstCreatePass&&(tNode.injectorIndex=lView.length,insertBloom(tView.data,tNode),insertBloom(lView,null),insertBloom(tView.blueprint,null));const parentLoc=getParentInjectorLocation(tNode,lView),injectorIndex=tNode.injectorIndex;if(hasParentInjector(parentLoc)){const parentIndex=getParentInjectorIndex(parentLoc),parentLView=getParentInjectorView(parentLoc,lView),parentData=parentLView[TVIEW].data;for(let i=0;i<8;i++)lView[injectorIndex+i]=parentLView[parentIndex+i]|parentData[parentIndex+i]}return lView[injectorIndex+8]=parentLoc,injectorIndex}function insertBloom(arr,footer){arr.push(0,0,0,0,0,0,0,0,footer)}function getInjectorIndex(tNode,lView){return-1===tNode.injectorIndex||tNode.parent&&tNode.parent.injectorIndex===tNode.injectorIndex||null===lView[tNode.injectorIndex+8]?-1:(ngDevMode&&assertIndexInRange(lView,tNode.injectorIndex),tNode.injectorIndex)}function getParentInjectorLocation(tNode,lView){if(tNode.parent&&-1!==tNode.parent.injectorIndex)return tNode.parent.injectorIndex;let declarationViewOffset=0,parentTNode=null,lViewCursor=lView;for(;null!==lViewCursor;){if(parentTNode=getTNodeFromLView(lViewCursor),null===parentTNode)return NO_PARENT_INJECTOR;if(ngDevMode&&parentTNode&&assertTNodeForLView(parentTNode,lViewCursor[DECLARATION_VIEW]),declarationViewOffset++,lViewCursor=lViewCursor[DECLARATION_VIEW],-1!==parentTNode.injectorIndex)return parentTNode.injectorIndex|declarationViewOffset<<16}return NO_PARENT_INJECTOR}function diPublicInInjector(injectorIndex,tView,token){!function bloomAdd(injectorIndex,tView,type){let id;ngDevMode&&assertEqual(tView.firstCreatePass,!0,"expected firstCreatePass to be true"),"string"==typeof type?id=type.charCodeAt(0)||0:type.hasOwnProperty(NG_ELEMENT_ID)&&(id=type[NG_ELEMENT_ID]),null==id&&(id=type[NG_ELEMENT_ID]=nextNgElementId++);const bloomHash=id&BLOOM_MASK,mask=1<<bloomHash;tView.data[injectorIndex+(bloomHash>>BLOOM_BUCKET_BITS)]|=mask}(injectorIndex,tView,token)}function notFoundValueOrThrow(notFoundValue,token,flags){if(flags&InjectFlags.Optional||void 0!==notFoundValue)return notFoundValue;throwProviderNotFoundError(token,"NodeInjector")}function lookupTokenUsingModuleInjector(lView,token,flags,notFoundValue){if(flags&InjectFlags.Optional&&void 0===notFoundValue&&(notFoundValue=null),!(flags&(InjectFlags.Self|InjectFlags.Host))){const moduleInjector=lView[INJECTOR$1],previousInjectImplementation=setInjectImplementation(void 0);try{return moduleInjector?moduleInjector.get(token,notFoundValue,flags&InjectFlags.Optional):injectRootLimpMode(token,notFoundValue,flags&InjectFlags.Optional)}finally{setInjectImplementation(previousInjectImplementation)}}return notFoundValueOrThrow(notFoundValue,token,flags)}function getOrCreateInjectable(tNode,lView,token,flags=InjectFlags.Default,notFoundValue){if(null!==tNode){if(2048&lView[FLAGS]&&!(flags&InjectFlags.Self)){const embeddedInjectorValue=function lookupTokenUsingEmbeddedInjector(tNode,lView,token,flags,notFoundValue){let currentTNode=tNode,currentLView=lView;for(;null!==currentTNode&&null!==currentLView&&2048&currentLView[FLAGS]&&!(512&currentLView[FLAGS]);){ngDevMode&&assertTNodeForLView(currentTNode,currentLView);const nodeInjectorValue=lookupTokenUsingNodeInjector(currentTNode,currentLView,token,flags|InjectFlags.Self,NOT_FOUND);if(nodeInjectorValue!==NOT_FOUND)return nodeInjectorValue;let parentTNode=currentTNode.parent;if(!parentTNode){const embeddedViewInjector=currentLView[EMBEDDED_VIEW_INJECTOR];if(embeddedViewInjector){const embeddedViewInjectorValue=embeddedViewInjector.get(token,NOT_FOUND,flags);if(embeddedViewInjectorValue!==NOT_FOUND)return embeddedViewInjectorValue}parentTNode=getTNodeFromLView(currentLView),currentLView=currentLView[DECLARATION_VIEW]}currentTNode=parentTNode}return notFoundValue}(tNode,lView,token,flags,NOT_FOUND);if(embeddedInjectorValue!==NOT_FOUND)return embeddedInjectorValue}const value=lookupTokenUsingNodeInjector(tNode,lView,token,flags,NOT_FOUND);if(value!==NOT_FOUND)return value}return lookupTokenUsingModuleInjector(lView,token,flags,notFoundValue)}function lookupTokenUsingNodeInjector(tNode,lView,token,flags,notFoundValue){const bloomHash=function bloomHashBitOrFactory(token){if(ngDevMode&&assertDefined(token,"token must be defined"),"string"==typeof token)return token.charCodeAt(0)||0;const tokenId=token.hasOwnProperty(NG_ELEMENT_ID)?token[NG_ELEMENT_ID]:void 0;return"number"==typeof tokenId?tokenId>=0?tokenId&BLOOM_MASK:(ngDevMode&&assertEqual(tokenId,-1,"Expecting to get Special Injector Id"),createNodeInjector):tokenId}(token);if("function"==typeof bloomHash){if(!enterDI(lView,tNode,flags))return flags&InjectFlags.Host?notFoundValueOrThrow(notFoundValue,token,flags):lookupTokenUsingModuleInjector(lView,token,flags,notFoundValue);try{let value;if(ngDevMode?runInInjectorProfilerContext(new NodeInjector(getCurrentTNode(),getLView()),token,(()=>{value=bloomHash(flags),null!=value&&emitInstanceCreatedByInjectorEvent(value)})):value=bloomHash(flags),null!=value||flags&InjectFlags.Optional)return value;throwProviderNotFoundError(token)}finally{leaveDI()}}else if("number"==typeof bloomHash){let previousTView=null,injectorIndex=getInjectorIndex(tNode,lView),parentLocation=NO_PARENT_INJECTOR,hostTElementNode=flags&InjectFlags.Host?lView[DECLARATION_COMPONENT_VIEW][T_HOST]:null;for((-1===injectorIndex||flags&InjectFlags.SkipSelf)&&(parentLocation=-1===injectorIndex?getParentInjectorLocation(tNode,lView):lView[injectorIndex+8],parentLocation!==NO_PARENT_INJECTOR&&shouldSearchParent(flags,!1)?(previousTView=lView[TVIEW],injectorIndex=getParentInjectorIndex(parentLocation),lView=getParentInjectorView(parentLocation,lView)):injectorIndex=-1);-1!==injectorIndex;){ngDevMode&&assertNodeInjector(lView,injectorIndex);const tView=lView[TVIEW];if(ngDevMode&&assertTNodeForLView(tView.data[injectorIndex+8],lView),bloomHasToken(bloomHash,injectorIndex,tView.data)){const instance=searchTokensOnInjector(injectorIndex,lView,token,previousTView,flags,hostTElementNode);if(instance!==NOT_FOUND)return instance}parentLocation=lView[injectorIndex+8],parentLocation!==NO_PARENT_INJECTOR&&shouldSearchParent(flags,lView[TVIEW].data[injectorIndex+8]===hostTElementNode)&&bloomHasToken(bloomHash,injectorIndex,lView)?(previousTView=tView,injectorIndex=getParentInjectorIndex(parentLocation),lView=getParentInjectorView(parentLocation,lView)):injectorIndex=-1}}return notFoundValue}function searchTokensOnInjector(injectorIndex,lView,token,previousTView,flags,hostTElementNode){const currentTView=lView[TVIEW],tNode=currentTView.data[injectorIndex+8],injectableIdx=locateDirectiveOrProvider(tNode,currentTView,token,null==previousTView?isComponentHost(tNode)&&includeViewProviders:previousTView!=currentTView&&!!(3&tNode.type),flags&InjectFlags.Host&&hostTElementNode===tNode);return null!==injectableIdx?getNodeInjectable(lView,currentTView,injectableIdx,tNode):NOT_FOUND}function locateDirectiveOrProvider(tNode,tView,token,canAccessViewProviders,isHostSpecialCase){const nodeProviderIndexes=tNode.providerIndexes,tInjectables=tView.data,injectablesStart=1048575&nodeProviderIndexes,directivesStart=tNode.directiveStart,directiveEnd=tNode.directiveEnd,cptViewProvidersCount=nodeProviderIndexes>>20,endIndex=isHostSpecialCase?injectablesStart+cptViewProvidersCount:directiveEnd;for(let i=canAccessViewProviders?injectablesStart:injectablesStart+cptViewProvidersCount;i<endIndex;i++){const providerTokenOrDef=tInjectables[i];if(i<directivesStart&&token===providerTokenOrDef||i>=directivesStart&&providerTokenOrDef.type===token)return i}if(isHostSpecialCase){const dirDef=tInjectables[directivesStart];if(dirDef&&isComponentDef(dirDef)&&dirDef.type===token)return directivesStart}return null}function getNodeInjectable(lView,tView,index,tNode){let value=lView[index];const tData=tView.data;if(function isFactory(obj){return obj instanceof NodeInjectorFactory}(value)){const factory=value;factory.resolving&&throwCyclicDependencyError(stringifyForError(tData[index]));const previousIncludeViewProviders=setIncludeViewProviders(factory.canSeeViewProviders);let prevInjectContext;if(factory.resolving=!0,ngDevMode){const token=tData[index].type||tData[index];prevInjectContext=setInjectorProfilerContext({injector:new NodeInjector(tNode,lView),token})}const previousInjectImplementation=factory.injectImpl?setInjectImplementation(factory.injectImpl):null,success=enterDI(lView,tNode,InjectFlags.Default);ngDevMode&&assertEqual(success,!0,"Because flags do not contain `SkipSelf' we expect this to always succeed.");try{value=lView[index]=factory.factory(void 0,tData,lView,tNode),ngDevMode&&emitInstanceCreatedByInjectorEvent(value),tView.firstCreatePass&&index>=tNode.directiveStart&&(ngDevMode&&function assertDirectiveDef(obj){void 0!==obj.type&&null!=obj.selectors&&void 0!==obj.inputs||throwError("Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.")}(tData[index]),function registerPreOrderHooks(directiveIndex,directiveDef,tView){ngDevMode&&assertFirstCreatePass(tView);const{ngOnChanges,ngOnInit,ngDoCheck}=directiveDef.type.prototype;if(ngOnChanges){const wrappedOnChanges=NgOnChangesFeatureImpl(directiveDef);(tView.preOrderHooks??=[]).push(directiveIndex,wrappedOnChanges),(tView.preOrderCheckHooks??=[]).push(directiveIndex,wrappedOnChanges)}ngOnInit&&(tView.preOrderHooks??=[]).push(0-directiveIndex,ngOnInit),ngDoCheck&&((tView.preOrderHooks??=[]).push(directiveIndex,ngDoCheck),(tView.preOrderCheckHooks??=[]).push(directiveIndex,ngDoCheck))}(index,tData[index],tView))}finally{ngDevMode&&setInjectorProfilerContext(prevInjectContext),null!==previousInjectImplementation&&setInjectImplementation(previousInjectImplementation),setIncludeViewProviders(previousIncludeViewProviders),factory.resolving=!1,leaveDI()}}return value}function bloomHasToken(bloomHash,injectorIndex,injectorView){const mask=1<<bloomHash;return!!(injectorView[injectorIndex+(bloomHash>>BLOOM_BUCKET_BITS)]&mask)}function shouldSearchParent(flags,isFirstHostTNode){return!(flags&InjectFlags.Self||flags&InjectFlags.Host&&isFirstHostTNode)}class NodeInjector{constructor(_tNode,_lView){this._tNode=_tNode,this._lView=_lView}get(token,notFoundValue,flags){return getOrCreateInjectable(this._tNode,this._lView,token,convertToBitFlags(flags),notFoundValue)}}function createNodeInjector(){return new NodeInjector(getCurrentTNode(),getLView())}function getTNodeFromLView(lView){const tView=lView[TVIEW],tViewType=tView.type;return 2===tViewType?(ngDevMode&&assertDefined(tView.declTNode,"Embedded TNodes should have declaration parents."),tView.declTNode):1===tViewType?lView[T_HOST]:null}function ɵɵinjectAttribute(attrNameToInject){return function injectAttributeImpl(tNode,attrNameToInject){if(ngDevMode&&assertTNodeType(tNode,15),ngDevMode&&assertDefined(tNode,"expecting tNode"),"class"===attrNameToInject)return tNode.classes;if("style"===attrNameToInject)return tNode.styles;const attrs=tNode.attrs;if(attrs){const attrsLength=attrs.length;let i=0;for(;i<attrsLength;){const value=attrs[i];if(isNameOnlyAttributeMarker(value))break;if(0===value)i+=2;else if("number"==typeof value)for(i++;i<attrsLength&&"string"==typeof attrs[i];)i++;else{if(value===attrNameToInject)return attrs[i+1];i+=2}}}return null}(getCurrentTNode(),attrNameToInject)}const Attribute=makeParamDecorator("Attribute",(attributeName=>({attributeName,__NG_ELEMENT_ID__:()=>ɵɵinjectAttribute(attributeName)})));let _reflect=null;function reflectDependencies(type){return convertDependencies(function getReflect(){return _reflect=_reflect||new ReflectionCapabilities}().parameters(type))}function convertDependencies(deps){return deps.map((dep=>function reflectDependency(dep){const meta={token:null,attribute:null,host:!1,optional:!1,self:!1,skipSelf:!1};if(Array.isArray(dep)&&dep.length>0)for(let j=0;j<dep.length;j++){const param=dep[j];if(void 0===param)continue;const proto=Object.getPrototypeOf(param);if(param instanceof Optional||"Optional"===proto.ngMetadataName)meta.optional=!0;else if(param instanceof SkipSelf||"SkipSelf"===proto.ngMetadataName)meta.skipSelf=!0;else if(param instanceof Self||"Self"===proto.ngMetadataName)meta.self=!0;else if(param instanceof Host||"Host"===proto.ngMetadataName)meta.host=!0;else if(param instanceof Inject)meta.token=param.token;else if(param instanceof Attribute){if(void 0===param.attributeName)throw new RuntimeError(204,ngDevMode&&"Attribute name must be defined.");meta.attribute=param.attributeName}else meta.token=param}else void 0===dep||Array.isArray(dep)&&0===dep.length?meta.token=null:meta.token=dep;return meta}(dep)))}new Map;let DOCUMENT;function getDocument(){if(void 0!==DOCUMENT)return DOCUMENT;if("undefined"!=typeof document)return document;throw new RuntimeError(210,("undefined"==typeof ngDevMode||ngDevMode)&&"The document object is not available in this context. Make sure the DOCUMENT injection token is provided.")}const APP_ID=new InjectionToken("AppId",{providedIn:"root",factory:()=>DEFAULT_APP_ID}),DEFAULT_APP_ID="ng",PLATFORM_ID=(new InjectionToken("Platform Initializer"),new InjectionToken("Platform ID",{providedIn:"platform",factory:()=>"unknown"})),ENVIRONMENT_INITIALIZER=(new InjectionToken("Application Packages Root URL"),new InjectionToken("AnimationModuleType"),new InjectionToken("CSP nonce",{providedIn:"root",factory:()=>getDocument().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null}),new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"ENABLED_SSR_FEATURES":"",{providedIn:"root",factory:()=>new Set}),new InjectionToken("ENVIRONMENT_INITIALIZER")),INJECTOR=new InjectionToken("INJECTOR",-1),INJECTOR_DEF_TYPES=new InjectionToken("INJECTOR_DEF_TYPES");class NullInjector{get(token,notFoundValue=THROW_IF_NOT_FOUND){if(notFoundValue===THROW_IF_NOT_FOUND){const error=new Error(`NullInjectorError: No provider for ${stringify(token)}!`);throw error.name="NullInjectorError",error}return notFoundValue}}function importProvidersFrom(...sources){return{ɵproviders:internalImportProvidersFrom(!0,sources),ɵfromNgModule:!0}}function internalImportProvidersFrom(checkForStandaloneCmp,...sources){const providersOut=[],dedup=new Set;let injectorTypesWithProviders;const collectProviders=provider=>{providersOut.push(provider)};return deepForEach(sources,(source=>{if(("undefined"==typeof ngDevMode||ngDevMode)&&checkForStandaloneCmp){const cmpDef=getComponentDef$1(source);if(cmpDef?.standalone)throw new RuntimeError(800,`Importing providers supports NgModule or ModuleWithProviders but got a standalone component "${stringifyForError(source)}"`)}const internalSource=source;walkProviderTree(internalSource,collectProviders,[],dedup)&&(injectorTypesWithProviders||=[],injectorTypesWithProviders.push(internalSource))})),void 0!==injectorTypesWithProviders&&processInjectorTypesWithProviders(injectorTypesWithProviders,collectProviders),providersOut}function processInjectorTypesWithProviders(typesWithProviders,visitor){for(let i=0;i<typesWithProviders.length;i++){const{ngModule,providers}=typesWithProviders[i];deepForEachProvider(providers,(provider=>{ngDevMode&&validateProvider(provider,providers||EMPTY_ARRAY,ngModule),visitor(provider,ngModule)}))}}function walkProviderTree(container,visitor,parents,dedup){if(!(container=resolveForwardRef(container)))return!1;let defType=null,injDef=getInjectorDef(container);const cmpDef=!injDef&&getComponentDef$1(container);if(injDef||cmpDef){if(cmpDef&&!cmpDef.standalone)return!1;defType=container}else{const ngModule=container.ngModule;if(injDef=getInjectorDef(ngModule),!injDef)return!1;defType=ngModule}if(ngDevMode&&-1!==parents.indexOf(defType)){throwCyclicDependencyError(stringify(defType),parents.map(stringify))}const isDuplicate=dedup.has(defType);if(cmpDef){if(isDuplicate)return!1;if(dedup.add(defType),cmpDef.dependencies){const deps="function"==typeof cmpDef.dependencies?cmpDef.dependencies():cmpDef.dependencies;for(const dep of deps)walkProviderTree(dep,visitor,parents,dedup)}}else{if(!injDef)return!1;{if(null!=injDef.imports&&!isDuplicate){let importTypesWithProviders;ngDevMode&&parents.push(defType),dedup.add(defType);try{deepForEach(injDef.imports,(imported=>{walkProviderTree(imported,visitor,parents,dedup)&&(importTypesWithProviders||=[],importTypesWithProviders.push(imported))}))}finally{ngDevMode&&parents.pop()}void 0!==importTypesWithProviders&&processInjectorTypesWithProviders(importTypesWithProviders,visitor)}if(!isDuplicate){const factory=getFactoryDef(defType)||(()=>new defType);visitor({provide:defType,useFactory:factory,deps:EMPTY_ARRAY},defType),visitor({provide:INJECTOR_DEF_TYPES,useValue:defType,multi:!0},defType),visitor({provide:ENVIRONMENT_INITIALIZER,useValue:()=>ɵɵinject(defType),multi:!0},defType)}const defProviders=injDef.providers;if(null!=defProviders&&!isDuplicate){const injectorType=container;deepForEachProvider(defProviders,(provider=>{ngDevMode&&validateProvider(provider,defProviders,injectorType),visitor(provider,injectorType)}))}}}return defType!==container&&void 0!==container.providers}function validateProvider(provider,providers,containerType){if(isTypeProvider(provider)||isValueProvider(provider)||isFactoryProvider(provider)||isExistingProvider(provider))return;resolveForwardRef(provider&&(provider.useClass||provider.provide))||throwInvalidProviderError(containerType,providers,provider)}function deepForEachProvider(providers,fn){for(let provider of providers)isEnvironmentProviders(provider)&&(provider=provider.ɵproviders),Array.isArray(provider)?deepForEachProvider(provider,fn):fn(provider)}const USE_VALUE$1=getClosureSafeProperty({provide:String,useValue:getClosureSafeProperty});function isValueProvider(value){return null!==value&&"object"==typeof value&&USE_VALUE$1 in value}function isExistingProvider(value){return!(!value||!value.useExisting)}function isFactoryProvider(value){return!(!value||!value.useFactory)}function isTypeProvider(value){return"function"==typeof value}const INJECTOR_SCOPE=new InjectionToken("Set Injector scope."),NOT_YET={},CIRCULAR={};let NULL_INJECTOR;function getNullInjector(){return void 0===NULL_INJECTOR&&(NULL_INJECTOR=new NullInjector),NULL_INJECTOR}class EnvironmentInjector{}class R3Injector extends EnvironmentInjector{get destroyed(){return this._destroyed}constructor(providers,parent,source,scopes){super(),this.parent=parent,this.source=source,this.scopes=scopes,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,forEachSingleProvider(providers,(provider=>this.processProvider(provider))),this.records.set(INJECTOR,makeRecord(void 0,this)),scopes.has("environment")&&this.records.set(EnvironmentInjector,makeRecord(void 0,this));const record=this.records.get(INJECTOR_SCOPE);null!=record&&"string"==typeof record.value&&this.scopes.add(record.value),this.injectorDefTypes=new Set(this.get(INJECTOR_DEF_TYPES.multi,EMPTY_ARRAY,InjectFlags.Self))}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const service of this._ngOnDestroyHooks)service.ngOnDestroy();const onDestroyHooks=this._onDestroyHooks;this._onDestroyHooks=[];for(const hook of onDestroyHooks)hook()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear()}}onDestroy(callback){return this.assertNotDestroyed(),this._onDestroyHooks.push(callback),()=>this.removeOnDestroy(callback)}runInContext(fn){this.assertNotDestroyed();const previousInjector=setCurrentInjector(this),previousInjectImplementation=setInjectImplementation(void 0);let prevInjectContext;ngDevMode&&(prevInjectContext=setInjectorProfilerContext({injector:this,token:null}));try{return fn()}finally{setCurrentInjector(previousInjector),setInjectImplementation(previousInjectImplementation),ngDevMode&&setInjectorProfilerContext(prevInjectContext)}}get(token,notFoundValue=THROW_IF_NOT_FOUND,flags=InjectFlags.Default){if(this.assertNotDestroyed(),token.hasOwnProperty(NG_ENV_ID))return token[NG_ENV_ID](this);let prevInjectContext;flags=convertToBitFlags(flags),ngDevMode&&(prevInjectContext=setInjectorProfilerContext({injector:this,token}));const previousInjector=setCurrentInjector(this),previousInjectImplementation=setInjectImplementation(void 0);try{if(!(flags&InjectFlags.SkipSelf)){let record=this.records.get(token);if(void 0===record){const def=function couldBeInjectableType(value){return"function"==typeof value||"object"==typeof value&&value instanceof InjectionToken}(token)&&getInjectableDef(token);def&&this.injectableDefInScope(def)?(ngDevMode&&runInInjectorProfilerContext(this,token,(()=>{emitProviderConfiguredEvent(token)})),record=makeRecord(injectableDefOrInjectorDefFactory(token),NOT_YET)):record=null,this.records.set(token,record)}if(null!=record)return this.hydrate(token,record)}const nextInjector=flags&InjectFlags.Self?getNullInjector():this.parent;return notFoundValue=flags&InjectFlags.Optional&&notFoundValue===THROW_IF_NOT_FOUND?null:notFoundValue,nextInjector.get(token,notFoundValue)}catch(e){if("NullInjectorError"===e.name){if((e.ngTempTokenPath=e.ngTempTokenPath||[]).unshift(stringify(token)),previousInjector)throw e;return catchInjectorError(e,token,"R3InjectorError",this.source)}throw e}finally{setInjectImplementation(previousInjectImplementation),setCurrentInjector(previousInjector),ngDevMode&&setInjectorProfilerContext(prevInjectContext)}}resolveInjectorInitializers(){const previousInjector=setCurrentInjector(this),previousInjectImplementation=setInjectImplementation(void 0);let prevInjectContext;ngDevMode&&(prevInjectContext=setInjectorProfilerContext({injector:this,token:null}));try{const initializers=this.get(ENVIRONMENT_INITIALIZER.multi,EMPTY_ARRAY,InjectFlags.Self);if(ngDevMode&&!Array.isArray(initializers))throw new RuntimeError(-209,`Unexpected type of the \`ENVIRONMENT_INITIALIZER\` token value (expected an array, but got ${typeof initializers}). Please check that the \`ENVIRONMENT_INITIALIZER\` token is configured as a \`multi: true\` provider.`);for(const initializer of initializers)initializer()}finally{setCurrentInjector(previousInjector),setInjectImplementation(previousInjectImplementation),ngDevMode&&setInjectorProfilerContext(prevInjectContext)}}toString(){const tokens=[],records=this.records;for(const token of records.keys())tokens.push(stringify(token));return`R3Injector[${tokens.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new RuntimeError(205,ngDevMode&&"Injector has already been destroyed.")}processProvider(provider){let token=isTypeProvider(provider=resolveForwardRef(provider))?provider:resolveForwardRef(provider&&provider.provide);const record=function providerToRecord(provider){if(isValueProvider(provider))return makeRecord(void 0,provider.useValue);return makeRecord(providerToFactory(provider),NOT_YET)}(provider);if(ngDevMode&&runInInjectorProfilerContext(this,token,(()=>{isValueProvider(provider)&&emitInstanceCreatedByInjectorEvent(provider.useValue),emitProviderConfiguredEvent(provider)})),isTypeProvider(provider)||!0!==provider.multi){const existing=this.records.get(token);ngDevMode&&existing&&void 0!==existing.multi&&throwMixedMultiProviderError()}else{let multiRecord=this.records.get(token);multiRecord?ngDevMode&&void 0===multiRecord.multi&&throwMixedMultiProviderError():(multiRecord=makeRecord(void 0,NOT_YET,!0),multiRecord.factory=()=>injectArgs(multiRecord.multi),this.records.set(token,multiRecord)),token=provider,multiRecord.multi.push(provider)}this.records.set(token,record)}hydrate(token,record){return ngDevMode&&record.value===CIRCULAR?throwCyclicDependencyError(stringify(token)):record.value===NOT_YET&&(record.value=CIRCULAR,ngDevMode?runInInjectorProfilerContext(this,token,(()=>{record.value=record.factory(),emitInstanceCreatedByInjectorEvent(record.value)})):record.value=record.factory()),"object"==typeof record.value&&record.value&&function hasOnDestroy(value){return null!==value&&"object"==typeof value&&"function"==typeof value.ngOnDestroy}(record.value)&&this._ngOnDestroyHooks.add(record.value),record.value}injectableDefInScope(def){if(!def.providedIn)return!1;const providedIn=resolveForwardRef(def.providedIn);return"string"==typeof providedIn?"any"===providedIn||this.scopes.has(providedIn):this.injectorDefTypes.has(providedIn)}removeOnDestroy(callback){const destroyCBIdx=this._onDestroyHooks.indexOf(callback);-1!==destroyCBIdx&&this._onDestroyHooks.splice(destroyCBIdx,1)}}function injectableDefOrInjectorDefFactory(token){const injectableDef=getInjectableDef(token),factory=null!==injectableDef?injectableDef.factory:getFactoryDef(token);if(null!==factory)return factory;if(token instanceof InjectionToken)throw new RuntimeError(204,ngDevMode&&`Token ${stringify(token)} is missing a ɵprov definition.`);if(token instanceof Function)return function getUndecoratedInjectableFactory(token){const paramLength=token.length;if(paramLength>0){const args=newArray(paramLength,"?");throw new RuntimeError(204,ngDevMode&&`Can't resolve all parameters for ${stringify(token)}: (${args.join(", ")}).`)}const inheritedInjectableDef=function getInheritedInjectableDef(type){const def=type&&(type[NG_PROV_DEF]||type[NG_INJECTABLE_DEF]);return def?(ngDevMode&&console.warn(`DEPRECATED: DI is instantiating a token "${type.name}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${type.name}" class.`),def):null}(token);return null!==inheritedInjectableDef?()=>inheritedInjectableDef.factory(token):()=>new token}(token);throw new RuntimeError(204,ngDevMode&&"unreachable")}function providerToFactory(provider,ngModuleType,providers){let factory;if(ngDevMode&&isEnvironmentProviders(provider)&&throwInvalidProviderError(void 0,providers,provider),isTypeProvider(provider)){const unwrappedProvider=resolveForwardRef(provider);return getFactoryDef(unwrappedProvider)||injectableDefOrInjectorDefFactory(unwrappedProvider)}if(isValueProvider(provider))factory=()=>resolveForwardRef(provider.useValue);else if(isFactoryProvider(provider))factory=()=>provider.useFactory(...injectArgs(provider.deps||[]));else if(isExistingProvider(provider))factory=()=>ɵɵinject(resolveForwardRef(provider.useExisting));else{const classRef=resolveForwardRef(provider&&(provider.useClass||provider.provide));if(ngDevMode&&!classRef&&throwInvalidProviderError(ngModuleType,providers,provider),!function hasDeps(value){return!!value.deps}(provider))return getFactoryDef(classRef)||injectableDefOrInjectorDefFactory(classRef);factory=()=>new classRef(...injectArgs(provider.deps))}return factory}function makeRecord(factory,value,multi=!1){return{factory,value,multi:multi?[]:void 0}}function forEachSingleProvider(providers,fn){for(const provider of providers)Array.isArray(provider)?forEachSingleProvider(provider,fn):provider&&isEnvironmentProviders(provider)?forEachSingleProvider(provider.ɵproviders,fn):fn(provider)}const angularCoreDiEnv={ɵɵdefineInjectable,ɵɵdefineInjector,ɵɵinject,ɵɵinvalidFactoryDep,resolveForwardRef};function compileInjectable(type,meta){let ngInjectableDef=null,ngFactoryDef=null;type.hasOwnProperty(NG_PROV_DEF)||Object.defineProperty(type,NG_PROV_DEF,{get:()=>{if(null===ngInjectableDef){const compiler=getCompilerFacade({usage:0,kind:"injectable",type});ngInjectableDef=compiler.compileInjectable(angularCoreDiEnv,`ng:///${type.name}/ɵprov.js`,function getInjectableMetadata(type,srcMeta){const meta=srcMeta||{providedIn:null},compilerMeta={name:type.name,type,typeArgumentCount:0,providedIn:meta.providedIn};(isUseClassProvider(meta)||isUseFactoryProvider(meta))&&void 0!==meta.deps&&(compilerMeta.deps=convertDependencies(meta.deps));isUseClassProvider(meta)?compilerMeta.useClass=meta.useClass:!function isUseValueProvider(meta){return USE_VALUE in meta}(meta)?isUseFactoryProvider(meta)?compilerMeta.useFactory=meta.useFactory:function isUseExistingProvider(meta){return void 0!==meta.useExisting}(meta)&&(compilerMeta.useExisting=meta.useExisting):compilerMeta.useValue=meta.useValue;return compilerMeta}(type,meta))}return ngInjectableDef}}),type.hasOwnProperty(NG_FACTORY_DEF)||Object.defineProperty(type,NG_FACTORY_DEF,{get:()=>{if(null===ngFactoryDef){const compiler=getCompilerFacade({usage:0,kind:"injectable",type});ngFactoryDef=compiler.compileFactory(angularCoreDiEnv,`ng:///${type.name}/ɵfac.js`,{name:type.name,type,typeArgumentCount:0,deps:reflectDependencies(type),target:compiler.FactoryTarget.Injectable})}return ngFactoryDef},configurable:!0})}const USE_VALUE=getClosureSafeProperty({provide:String,useValue:getClosureSafeProperty});function isUseClassProvider(meta){return void 0!==meta.useClass}function isUseFactoryProvider(meta){return void 0!==meta.useFactory}(function makeDecorator(name,props,parentClass,additionalProcessing,typeFn){return noSideEffects((()=>{const metaCtor=makeMetadataCtor(props);function DecoratorFactory(...args){if(this instanceof DecoratorFactory)return metaCtor.call(this,...args),this;const annotationInstance=new DecoratorFactory(...args);return function TypeDecorator(cls){typeFn&&typeFn(cls,...args);return(cls.hasOwnProperty(ANNOTATIONS)?cls[ANNOTATIONS]:Object.defineProperty(cls,ANNOTATIONS,{value:[]})[ANNOTATIONS]).push(annotationInstance),additionalProcessing&&additionalProcessing(cls),cls}}return parentClass&&(DecoratorFactory.prototype=Object.create(parentClass.prototype)),DecoratorFactory.prototype.ngMetadataName=name,DecoratorFactory.annotationCls=DecoratorFactory,DecoratorFactory}))})("Injectable",void 0,void 0,void 0,((type,meta)=>compileInjectable(type,meta)));function createInjector(defType,parent=null,additionalProviders=null,name){const injector=createInjectorWithoutInjectorInstances(defType,parent,additionalProviders,name);return injector.resolveInjectorInitializers(),injector}function createInjectorWithoutInjectorInstances(defType,parent=null,additionalProviders=null,name,scopes=new Set){const providers=[additionalProviders||EMPTY_ARRAY,importProvidersFrom(defType)];return name=name||("object"==typeof defType?void 0:stringify(defType)),new R3Injector(providers,parent||getNullInjector(),name||null,scopes)}class testing_Injector{static#_=this.THROW_IF_NOT_FOUND=THROW_IF_NOT_FOUND;static#_2=this.NULL=new NullInjector;static create(options,parent){if(Array.isArray(options))return createInjector({name:""},parent,options,"");{const name=options.name??"";return createInjector({name},options.parent,options.providers,name)}}static#_3=this.ɵprov=ɵɵdefineInjectable({token:testing_Injector,providedIn:"any",factory:()=>ɵɵinject(INJECTOR)});static#_4=this.__NG_ELEMENT_ID__=-1}let shouldThrowErrorOnUnknownProperty=!1;function reportUnknownPropertyError(message){if(shouldThrowErrorOnUnknownProperty)throw new RuntimeError(303,message);console.error(formatRuntimeError(303,message))}new Map([["ngIf","NgIf"],["ngFor","NgFor"],["ngSwitchCase","NgSwitchCase"],["ngSwitchDefault","NgSwitchDefault"]]);function hasInSkipHydrationBlockFlag(tNode){return!(128&~tNode.flags)}var RendererStyleFlags2;!function(RendererStyleFlags2){RendererStyleFlags2[RendererStyleFlags2.Important=1]="Important",RendererStyleFlags2[RendererStyleFlags2.DashCase=2]="DashCase"}(RendererStyleFlags2||(RendererStyleFlags2={}));const TRACKED_LVIEWS=new Map;let uniqueIdCounter=0;const MONKEY_PATCH_KEY_NAME="__ngContext__";function attachPatchData(target,data){ngDevMode&&assertDefined(target,"Target expected"),isLView(data)?(target[MONKEY_PATCH_KEY_NAME]=data[ID],function registerLView(lView){ngDevMode&&assertNumber(lView[ID],"LView must have an ID in order to be registered"),TRACKED_LVIEWS.set(lView[ID],lView)}(data)):target[MONKEY_PATCH_KEY_NAME]=data}let _icuContainerIterate;function icuContainerIterate(tIcuContainerNode,lView){return _icuContainerIterate(tIcuContainerNode,lView)}function getLViewParent(lView){ngDevMode&&assertLView(lView);const parent=lView[PARENT];return isLContainer(parent)?parent[PARENT]:parent}function getFirstLContainer(lView){return getNearestLContainer(lView[CHILD_HEAD])}function getNextLContainer(container){return getNearestLContainer(container[NEXT])}function getNearestLContainer(viewOrContainer){for(;null!==viewOrContainer&&!isLContainer(viewOrContainer);)viewOrContainer=viewOrContainer[NEXT];return viewOrContainer}function applyToElementOrContainer(action,renderer,parent,lNodeToHandle,beforeNode){if(null!=lNodeToHandle){let lContainer,isComponent=!1;isLContainer(lNodeToHandle)?lContainer=lNodeToHandle:isLView(lNodeToHandle)&&(isComponent=!0,ngDevMode&&assertDefined(lNodeToHandle[HOST],"HOST must be defined for a component LView"),lNodeToHandle=lNodeToHandle[HOST]);const rNode=unwrapRNode(lNodeToHandle);0===action&&null!==parent?null==beforeNode?nativeAppendChild(renderer,parent,rNode):nativeInsertBefore(renderer,parent,rNode,beforeNode||null,!0):1===action&&null!==parent?nativeInsertBefore(renderer,parent,rNode,beforeNode||null,!0):2===action?nativeRemoveNode(renderer,rNode,isComponent):3===action&&(ngDevMode&&ngDevMode.rendererDestroyNode++,renderer.destroyNode(rNode)),null!=lContainer&&function applyContainer(renderer,action,lContainer,parentRElement,beforeNode){ngDevMode&&assertLContainer(lContainer);const anchor=lContainer[NATIVE],native=unwrapRNode(lContainer);anchor!==native&&applyToElementOrContainer(action,renderer,parentRElement,anchor,beforeNode);for(let i=CONTAINER_HEADER_OFFSET;i<lContainer.length;i++){const lView=lContainer[i];applyView(lView[TVIEW],lView,renderer,action,parentRElement,anchor)}}(renderer,action,lContainer,parent,beforeNode)}}function createElementNode(renderer,name,namespace){return ngDevMode&&ngDevMode.rendererCreateElement++,renderer.createElement(name,namespace)}function insertView(tView,lView,lContainer,index){ngDevMode&&assertLView(lView),ngDevMode&&assertLContainer(lContainer);const indexInContainer=CONTAINER_HEADER_OFFSET+index,containerLength=lContainer.length;index>0&&(lContainer[indexInContainer-1][NEXT]=lView),index<containerLength-CONTAINER_HEADER_OFFSET?(lView[NEXT]=lContainer[indexInContainer],addToArray(lContainer,CONTAINER_HEADER_OFFSET+index,lView)):(lContainer.push(lView),lView[NEXT]=null),lView[PARENT]=lContainer;const declarationLContainer=lView[DECLARATION_LCONTAINER];null!==declarationLContainer&&lContainer!==declarationLContainer&&function trackMovedView(declarationContainer,lView){ngDevMode&&assertDefined(lView,"LView required"),ngDevMode&&assertLContainer(declarationContainer);const movedViews=declarationContainer[MOVED_VIEWS],insertedLContainer=lView[PARENT];ngDevMode&&assertLContainer(insertedLContainer);const insertedComponentLView=insertedLContainer[PARENT][DECLARATION_COMPONENT_VIEW];ngDevMode&&assertDefined(insertedComponentLView,"Missing insertedComponentLView");const declaredComponentLView=lView[DECLARATION_COMPONENT_VIEW];ngDevMode&&assertDefined(declaredComponentLView,"Missing declaredComponentLView"),declaredComponentLView!==insertedComponentLView&&(declarationContainer[HAS_TRANSPLANTED_VIEWS]=!0);null===movedViews?declarationContainer[MOVED_VIEWS]=[lView]:movedViews.push(lView)}(declarationLContainer,lView);const lQueries=lView[QUERIES];null!==lQueries&&lQueries.insertView(tView),lView[FLAGS]|=128}function detachMovedView(declarationContainer,lView){ngDevMode&&assertLContainer(declarationContainer),ngDevMode&&assertDefined(declarationContainer[MOVED_VIEWS],"A projected view should belong to a non-empty projected views collection");const movedViews=declarationContainer[MOVED_VIEWS],declarationViewIndex=movedViews.indexOf(lView),insertionLContainer=lView[PARENT];ngDevMode&&assertLContainer(insertionLContainer),clearViewRefreshFlag(lView),movedViews.splice(declarationViewIndex,1)}function detachView(lContainer,removeIndex){if(lContainer.length<=CONTAINER_HEADER_OFFSET)return;const indexInContainer=CONTAINER_HEADER_OFFSET+removeIndex,viewToDetach=lContainer[indexInContainer];if(viewToDetach){const declarationLContainer=viewToDetach[DECLARATION_LCONTAINER];null!==declarationLContainer&&declarationLContainer!==lContainer&&detachMovedView(declarationLContainer,viewToDetach),removeIndex>0&&(lContainer[indexInContainer-1][NEXT]=viewToDetach[NEXT]);const removedLView=removeFromArray(lContainer,CONTAINER_HEADER_OFFSET+removeIndex);!function removeViewFromDOM(tView,lView){applyView(tView,lView,lView[RENDERER],2,null,null),lView[HOST]=null,lView[T_HOST]=null}(viewToDetach[TVIEW],viewToDetach);const lQueries=removedLView[QUERIES];null!==lQueries&&lQueries.detachView(removedLView[TVIEW]),viewToDetach[PARENT]=null,viewToDetach[NEXT]=null,viewToDetach[FLAGS]&=-129}return viewToDetach}function destroyLView(tView,lView){if(!(256&lView[FLAGS])){const renderer=lView[RENDERER];lView[REACTIVE_TEMPLATE_CONSUMER]&&consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]),lView[REACTIVE_HOST_BINDING_CONSUMER]&&consumerDestroy(lView[REACTIVE_HOST_BINDING_CONSUMER]),renderer.destroyNode&&applyView(tView,lView,renderer,3,null,null),function destroyViewTree(rootView){let lViewOrLContainer=rootView[CHILD_HEAD];if(!lViewOrLContainer)return cleanUpView(rootView[TVIEW],rootView);for(;lViewOrLContainer;){let next=null;if(isLView(lViewOrLContainer))next=lViewOrLContainer[CHILD_HEAD];else{ngDevMode&&assertLContainer(lViewOrLContainer);const firstView=lViewOrLContainer[CONTAINER_HEADER_OFFSET];firstView&&(next=firstView)}if(!next){for(;lViewOrLContainer&&!lViewOrLContainer[NEXT]&&lViewOrLContainer!==rootView;)isLView(lViewOrLContainer)&&cleanUpView(lViewOrLContainer[TVIEW],lViewOrLContainer),lViewOrLContainer=lViewOrLContainer[PARENT];null===lViewOrLContainer&&(lViewOrLContainer=rootView),isLView(lViewOrLContainer)&&cleanUpView(lViewOrLContainer[TVIEW],lViewOrLContainer),next=lViewOrLContainer&&lViewOrLContainer[NEXT]}lViewOrLContainer=next}}(lView)}}function cleanUpView(tView,lView){if(!(256&lView[FLAGS])){lView[FLAGS]&=-129,lView[FLAGS]|=256,function executeOnDestroys(tView,lView){let destroyHooks;if(null!=tView&&null!=(destroyHooks=tView.destroyHooks))for(let i=0;i<destroyHooks.length;i+=2){const context=lView[destroyHooks[i]];if(!(context instanceof NodeInjectorFactory)){const toCall=destroyHooks[i+1];if(Array.isArray(toCall))for(let j=0;j<toCall.length;j+=2){const callContext=context[toCall[j]],hook=toCall[j+1];profiler(4,callContext,hook);try{hook.call(callContext)}finally{profiler(5,callContext,hook)}}else{profiler(4,context,toCall);try{toCall.call(context)}finally{profiler(5,context,toCall)}}}}}(tView,lView),function processCleanups(tView,lView){const tCleanup=tView.cleanup,lCleanup=lView[CLEANUP];if(null!==tCleanup)for(let i=0;i<tCleanup.length-1;i+=2)if("string"==typeof tCleanup[i]){const targetIdx=tCleanup[i+3];ngDevMode&&assertNumber(targetIdx,"cleanup target must be a number"),targetIdx>=0?lCleanup[targetIdx]():lCleanup[-targetIdx].unsubscribe(),i+=2}else{const context=lCleanup[tCleanup[i+1]];tCleanup[i].call(context)}null!==lCleanup&&(lView[CLEANUP]=null);const destroyHooks=lView[ON_DESTROY_HOOKS];if(null!==destroyHooks){lView[ON_DESTROY_HOOKS]=null;for(let i=0;i<destroyHooks.length;i++){const destroyHooksFn=destroyHooks[i];ngDevMode&&assertFunction(destroyHooksFn,"Expecting destroy hook to be a function."),destroyHooksFn()}}}(tView,lView),1===lView[TVIEW].type&&(ngDevMode&&ngDevMode.rendererDestroy++,lView[RENDERER].destroy());const declarationContainer=lView[DECLARATION_LCONTAINER];if(null!==declarationContainer&&isLContainer(lView[PARENT])){declarationContainer!==lView[PARENT]&&detachMovedView(declarationContainer,lView);const lQueries=lView[QUERIES];null!==lQueries&&lQueries.detachView(tView)}!function unregisterLView(lView){ngDevMode&&assertNumber(lView[ID],"Cannot stop tracking an LView that does not have an ID"),TRACKED_LVIEWS.delete(lView[ID])}(lView)}}function nativeInsertBefore(renderer,parent,child,beforeNode,isMove){ngDevMode&&ngDevMode.rendererInsertBefore++,renderer.insertBefore(parent,child,beforeNode,isMove)}function nativeAppendChild(renderer,parent,child){ngDevMode&&ngDevMode.rendererAppendChild++,ngDevMode&&assertDefined(parent,"parent node must be defined"),renderer.appendChild(parent,child)}function nativeParentNode(renderer,node){return renderer.parentNode(node)}function getFirstNativeNode(lView,tNode){if(null!==tNode){ngDevMode&&assertTNodeType(tNode,63);const tNodeType=tNode.type;if(3&tNodeType)return getNativeByTNode(tNode,lView);if(4&tNodeType)return getBeforeNodeForView(-1,lView[tNode.index]);if(8&tNodeType){const elIcuContainerChild=tNode.child;if(null!==elIcuContainerChild)return getFirstNativeNode(lView,elIcuContainerChild);{const rNodeOrLContainer=lView[tNode.index];return isLContainer(rNodeOrLContainer)?getBeforeNodeForView(-1,rNodeOrLContainer):unwrapRNode(rNodeOrLContainer)}}if(32&tNodeType){return icuContainerIterate(tNode,lView)()||unwrapRNode(lView[tNode.index])}{const projectionNodes=getProjectionNodes(lView,tNode);if(null!==projectionNodes){if(Array.isArray(projectionNodes))return projectionNodes[0];const parentView=getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);return ngDevMode&&assertParentView(parentView),getFirstNativeNode(parentView,projectionNodes)}return getFirstNativeNode(lView,tNode.next)}}return null}function getProjectionNodes(lView,tNode){if(null!==tNode){const componentHost=lView[DECLARATION_COMPONENT_VIEW][T_HOST],slotIdx=tNode.projection;return ngDevMode&&function assertProjectionSlots(lView,errMessage){assertDefined(lView[DECLARATION_COMPONENT_VIEW],"Component views should exist."),assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection,errMessage||"Components with projection nodes (<ng-content>) must have projection slots defined.")}(lView),componentHost.projection[slotIdx]}return null}function getBeforeNodeForView(viewIndexInContainer,lContainer){const nextViewIndex=CONTAINER_HEADER_OFFSET+viewIndexInContainer+1;if(nextViewIndex<lContainer.length){const lView=lContainer[nextViewIndex],firstTNodeOfView=lView[TVIEW].firstChild;if(null!==firstTNodeOfView)return getFirstNativeNode(lView,firstTNodeOfView)}return lContainer[NATIVE]}function nativeRemoveNode(renderer,rNode,isHostElement){ngDevMode&&ngDevMode.rendererRemoveNode++;const nativeParent=nativeParentNode(renderer,rNode);nativeParent&&function nativeRemoveChild(renderer,parent,child,isHostElement){renderer.removeChild(parent,child,isHostElement)}(renderer,nativeParent,rNode,isHostElement)}function applyNodes(renderer,action,tNode,lView,parentRElement,beforeNode,isProjection){for(;null!=tNode;){ngDevMode&&assertTNodeForLView(tNode,lView),ngDevMode&&assertTNodeType(tNode,63);const rawSlotValue=lView[tNode.index],tNodeType=tNode.type;if(isProjection&&0===action&&(rawSlotValue&&attachPatchData(unwrapRNode(rawSlotValue),lView),tNode.flags|=2),32&~tNode.flags)if(8&tNodeType)applyNodes(renderer,action,tNode.child,lView,parentRElement,beforeNode,!1),applyToElementOrContainer(action,renderer,parentRElement,rawSlotValue,beforeNode);else if(32&tNodeType){const nextRNode=icuContainerIterate(tNode,lView);let rNode;for(;rNode=nextRNode();)applyToElementOrContainer(action,renderer,parentRElement,rNode,beforeNode);applyToElementOrContainer(action,renderer,parentRElement,rawSlotValue,beforeNode)}else 16&tNodeType?applyProjectionRecursive(renderer,action,lView,tNode,parentRElement,beforeNode):(ngDevMode&&assertTNodeType(tNode,7),applyToElementOrContainer(action,renderer,parentRElement,rawSlotValue,beforeNode));tNode=isProjection?tNode.projectionNext:tNode.next}}function applyView(tView,lView,renderer,action,parentRElement,beforeNode){applyNodes(renderer,action,tView.firstChild,lView,parentRElement,beforeNode,!1)}function applyProjectionRecursive(renderer,action,lView,tProjectionNode,parentRElement,beforeNode){const componentLView=lView[DECLARATION_COMPONENT_VIEW],componentNode=componentLView[T_HOST];ngDevMode&&assertEqual(typeof tProjectionNode.projection,"number","expecting projection index");const nodeToProjectOrRNodes=componentNode.projection[tProjectionNode.projection];if(Array.isArray(nodeToProjectOrRNodes))for(let i=0;i<nodeToProjectOrRNodes.length;i++){applyToElementOrContainer(action,renderer,parentRElement,nodeToProjectOrRNodes[i],beforeNode)}else{let nodeToProject=nodeToProjectOrRNodes;const projectedComponentLView=componentLView[PARENT];hasInSkipHydrationBlockFlag(tProjectionNode)&&(nodeToProject.flags|=128),applyNodes(renderer,action,nodeToProject,projectedComponentLView,parentRElement,beforeNode,!0)}}function writeDirectClass(renderer,element,newValue){ngDevMode&&assertString(newValue,"'newValue' should be a string"),""===newValue?renderer.removeAttribute(element,"class"):renderer.setAttribute(element,"class",newValue),ngDevMode&&ngDevMode.rendererSetClassName++}function setupStaticAttributes(renderer,element,tNode){const{mergedAttrs,classes,styles}=tNode;null!==mergedAttrs&&setUpAttributes(renderer,element,mergedAttrs),null!==classes&&writeDirectClass(renderer,element,classes),null!==styles&&function writeDirectStyle(renderer,element,newValue){ngDevMode&&assertString(newValue,"'newValue' should be a string"),renderer.setAttribute(element,"style",newValue),ngDevMode&&ngDevMode.rendererSetStyle++}(renderer,element,styles)}function tagSet(tags){const res={};for(const t of tags.split(","))res[t]=!0;return res}function testing_merge(...sets){const res={};for(const s of sets)for(const v in s)s.hasOwnProperty(v)&&(res[v]=!0);return res}const VOID_ELEMENTS=tagSet("area,br,col,hr,img,wbr"),OPTIONAL_END_TAG_BLOCK_ELEMENTS=tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),OPTIONAL_END_TAG_INLINE_ELEMENTS=tagSet("rp,rt"),OPTIONAL_END_TAG_ELEMENTS=testing_merge(OPTIONAL_END_TAG_INLINE_ELEMENTS,OPTIONAL_END_TAG_BLOCK_ELEMENTS),BLOCK_ELEMENTS=testing_merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS,tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),INLINE_ELEMENTS=testing_merge(OPTIONAL_END_TAG_INLINE_ELEMENTS,tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),URI_ATTRS=(testing_merge(VOID_ELEMENTS,BLOCK_ELEMENTS,INLINE_ELEMENTS,OPTIONAL_END_TAG_ELEMENTS),tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href")),HTML_ATTRS=tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),ARIA_ATTRS=tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext");testing_merge(URI_ATTRS,HTML_ATTRS,ARIA_ATTRS),tagSet("script,style,template");var SecurityContext;function initTransferState(){const transferState=new TransferState;return"browser"===inject$1(PLATFORM_ID)&&(transferState.store=function retrieveTransferredState(doc,appId){const script=doc.getElementById(appId+"-state");if(script?.textContent)try{return JSON.parse(script.textContent)}catch(e){console.warn("Exception while restoring TransferState for app "+appId,e)}return{}}(getDocument(),inject$1(APP_ID))),transferState}!function(SecurityContext){SecurityContext[SecurityContext.NONE=0]="NONE",SecurityContext[SecurityContext.HTML=1]="HTML",SecurityContext[SecurityContext.STYLE=2]="STYLE",SecurityContext[SecurityContext.SCRIPT=3]="SCRIPT",SecurityContext[SecurityContext.URL=4]="URL",SecurityContext[SecurityContext.RESOURCE_URL=5]="RESOURCE_URL"}(SecurityContext||(SecurityContext={}));class TransferState{constructor(){this.store={},this.onSerializeCallbacks={}}static#_=this.ɵprov=ɵɵdefineInjectable({token:TransferState,providedIn:"root",factory:initTransferState});get(key,defaultValue){return void 0!==this.store[key]?this.store[key]:defaultValue}set(key,value){this.store[key]=value}remove(key){delete this.store[key]}hasKey(key){return this.store.hasOwnProperty(key)}get isEmpty(){return 0===Object.keys(this.store).length}onSerialize(key,callback){this.onSerializeCallbacks[key]=callback}toJson(){for(const key in this.onSerializeCallbacks)if(this.onSerializeCallbacks.hasOwnProperty(key))try{this.store[key]=this.onSerializeCallbacks[key]()}catch(e){console.warn("Exception in onSerialize callback: ",e)}return JSON.stringify(this.store).replace(/</g,"\\u003C")}}const REFERENCE_NODE_HOST="h",REFERENCE_NODE_BODY="b";var NodeNavigationStep;!function(NodeNavigationStep){NodeNavigationStep.FirstChild="f",NodeNavigationStep.NextSibling="n"}(NodeNavigationStep||(NodeNavigationStep={}));let _retrieveHydrationInfoImpl=(rNode,injector,isRootView)=>null;function retrieveHydrationInfo(rNode,injector,isRootView=!1){return _retrieveHydrationInfoImpl(rNode,injector,isRootView)}class ComponentRef$1{}class ComponentFactory$1{}const ERROR_COMPONENT="ngComponent";class _NullComponentFactoryResolver{resolveComponentFactory(component){throw function noComponentFactoryError(component){const error=Error(`No component factory found for ${stringify(component)}.`);return error[ERROR_COMPONENT]=component,error}(component)}}class ComponentFactoryResolver$1{static#_=this.NULL=new _NullComponentFactoryResolver}function injectElementRef(){return createElementRef(getCurrentTNode(),getLView())}function createElementRef(tNode,lView){return new ElementRef(getNativeByTNode(tNode,lView))}class ElementRef{constructor(nativeElement){this.nativeElement=nativeElement}static#_=this.__NG_ELEMENT_ID__=injectElementRef}class RendererFactory2{}class Renderer2{constructor(){this.destroyNode=null}static#_=this.__NG_ELEMENT_ID__=()=>function injectRenderer2(){const lView=getLView(),nodeAtIndex=getComponentLViewByIndex(getCurrentTNode().index,lView);return(isLView(nodeAtIndex)?nodeAtIndex:lView)[RENDERER]}()}class Sanitizer{static#_=this.ɵprov=ɵɵdefineInjectable({token:Sanitizer,providedIn:"root",factory:()=>null})}const VERSION=new class Version{constructor(full){this.full=full,this.major=full.split(".")[0],this.minor=full.split(".")[1],this.patch=full.split(".").slice(2).join(".")}}("16.2.12"),NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR={};function getOriginalError(error){return error.ngOriginalError}class ErrorHandler{constructor(){this._console=console}handleError(error){const originalError=this._findOriginalError(error);this._console.error("ERROR",error),originalError&&this._console.error("ORIGINAL ERROR",originalError)}_findOriginalError(error){let e=error&&getOriginalError(error);for(;e&&getOriginalError(e);)e=getOriginalError(e);return e||null}}class DestroyRef{static#_=this.__NG_ELEMENT_ID__=injectDestroyRef;static#_2=this.__NG_ENV_ID__=injector=>injector}class NodeInjectorDestroyRef extends DestroyRef{constructor(_lView){super(),this._lView=_lView}onDestroy(callback){return storeLViewOnDestroy(this._lView,callback),()=>function removeLViewOnDestroy(lView,onDestroyCallback){if(null===lView[ON_DESTROY_HOOKS])return;const destroyCBIdx=lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);-1!==destroyCBIdx&&lView[ON_DESTROY_HOOKS].splice(destroyCBIdx,1)}(this._lView,callback)}}function injectDestroyRef(){return new NodeInjectorDestroyRef(getLView())}class EventEmitter_ extends Subject.B{constructor(isAsync=!1){super(),this.__isAsync=isAsync}emit(value){super.next(value)}subscribe(observerOrNext,error,complete){let nextFn=observerOrNext,errorFn=error||(()=>null),completeFn=complete;if(observerOrNext&&"object"==typeof observerOrNext){const observer=observerOrNext;nextFn=observer.next?.bind(observer),errorFn=observer.error?.bind(observer),completeFn=observer.complete?.bind(observer)}this.__isAsync&&(errorFn=_wrapInTimeout(errorFn),nextFn&&(nextFn=_wrapInTimeout(nextFn)),completeFn&&(completeFn=_wrapInTimeout(completeFn)));const sink=super.subscribe({next:nextFn,error:errorFn,complete:completeFn});return observerOrNext instanceof Subscription.yU&&observerOrNext.add(sink),sink}}function _wrapInTimeout(fn){return value=>{setTimeout(fn,void 0,value)}}const EventEmitter=EventEmitter_;function noop(...args){}class AsyncStackTaggingZoneSpec{constructor(namePrefix,consoleAsyncStackTaggingImpl=console){this.name="asyncStackTagging for "+namePrefix,this.createTask=consoleAsyncStackTaggingImpl?.createTask??(()=>null)}onScheduleTask(delegate,_current,target,task){return task.consoleTask=this.createTask(`Zone - ${task.source||task.type}`),delegate.scheduleTask(target,task)}onInvokeTask(delegate,_currentZone,targetZone,task,applyThis,applyArgs){let ret;return ret=task.consoleTask?task.consoleTask.run((()=>delegate.invokeTask(targetZone,task,applyThis,applyArgs))):delegate.invokeTask(targetZone,task,applyThis,applyArgs),ret}}class NgZone{constructor({enableLongStackTrace=!1,shouldCoalesceEventChangeDetection=!1,shouldCoalesceRunChangeDetection=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new EventEmitter(!1),this.onMicrotaskEmpty=new EventEmitter(!1),this.onStable=new EventEmitter(!1),this.onError=new EventEmitter(!1),"undefined"==typeof Zone)throw new RuntimeError(908,ngDevMode&&"In this configuration Angular requires Zone.js");Zone.assertZonePatched();const self=this;self._nesting=0,self._outer=self._inner=Zone.current,ngDevMode&&(self._inner=self._inner.fork(new AsyncStackTaggingZoneSpec("Angular"))),Zone.TaskTrackingZoneSpec&&(self._inner=self._inner.fork(new Zone.TaskTrackingZoneSpec)),enableLongStackTrace&&Zone.longStackTraceZoneSpec&&(self._inner=self._inner.fork(Zone.longStackTraceZoneSpec)),self.shouldCoalesceEventChangeDetection=!shouldCoalesceRunChangeDetection&&shouldCoalesceEventChangeDetection,self.shouldCoalesceRunChangeDetection=shouldCoalesceRunChangeDetection,self.lastRequestAnimationFrameId=-1,self.nativeRequestAnimationFrame=function getNativeRequestAnimationFrame(){const isBrowser="function"==typeof _global.requestAnimationFrame;let nativeRequestAnimationFrame=_global[isBrowser?"requestAnimationFrame":"setTimeout"],nativeCancelAnimationFrame=_global[isBrowser?"cancelAnimationFrame":"clearTimeout"];if("undefined"!=typeof Zone&&nativeRequestAnimationFrame&&nativeCancelAnimationFrame){const unpatchedRequestAnimationFrame=nativeRequestAnimationFrame[Zone.__symbol__("OriginalDelegate")];unpatchedRequestAnimationFrame&&(nativeRequestAnimationFrame=unpatchedRequestAnimationFrame);const unpatchedCancelAnimationFrame=nativeCancelAnimationFrame[Zone.__symbol__("OriginalDelegate")];unpatchedCancelAnimationFrame&&(nativeCancelAnimationFrame=unpatchedCancelAnimationFrame)}return{nativeRequestAnimationFrame,nativeCancelAnimationFrame}}().nativeRequestAnimationFrame,function forkInnerZoneWithAngularBehavior(zone){const delayChangeDetectionForEventsDelegate=()=>{!function delayChangeDetectionForEvents(zone){if(zone.isCheckStableRunning||-1!==zone.lastRequestAnimationFrameId)return;zone.lastRequestAnimationFrameId=zone.nativeRequestAnimationFrame.call(_global,(()=>{zone.fakeTopEventTask||(zone.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",(()=>{zone.lastRequestAnimationFrameId=-1,updateMicroTaskStatus(zone),zone.isCheckStableRunning=!0,checkStable(zone),zone.isCheckStableRunning=!1}),void 0,(()=>{}),(()=>{}))),zone.fakeTopEventTask.invoke()})),updateMicroTaskStatus(zone)}(zone)};zone._inner=zone._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(delegate,current,target,task,applyThis,applyArgs)=>{if(function shouldBeIgnoredByZone(applyArgs){if(!Array.isArray(applyArgs))return!1;if(1!==applyArgs.length)return!1;return!0===applyArgs[0].data?.__ignore_ng_zone__}(applyArgs))return delegate.invokeTask(target,task,applyThis,applyArgs);try{return onEnter(zone),delegate.invokeTask(target,task,applyThis,applyArgs)}finally{(zone.shouldCoalesceEventChangeDetection&&"eventTask"===task.type||zone.shouldCoalesceRunChangeDetection)&&delayChangeDetectionForEventsDelegate(),onLeave(zone)}},onInvoke:(delegate,current,target,callback,applyThis,applyArgs,source)=>{try{return onEnter(zone),delegate.invoke(target,callback,applyThis,applyArgs,source)}finally{zone.shouldCoalesceRunChangeDetection&&delayChangeDetectionForEventsDelegate(),onLeave(zone)}},onHasTask:(delegate,current,target,hasTaskState)=>{delegate.hasTask(target,hasTaskState),current===target&&("microTask"==hasTaskState.change?(zone._hasPendingMicrotasks=hasTaskState.microTask,updateMicroTaskStatus(zone),checkStable(zone)):"macroTask"==hasTaskState.change&&(zone.hasPendingMacrotasks=hasTaskState.macroTask))},onHandleError:(delegate,current,target,error)=>(delegate.handleError(target,error),zone.runOutsideAngular((()=>zone.onError.emit(error))),!1)})}(self)}static isInAngularZone(){return"undefined"!=typeof Zone&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!NgZone.isInAngularZone())throw new RuntimeError(909,ngDevMode&&"Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(NgZone.isInAngularZone())throw new RuntimeError(909,ngDevMode&&"Expected to not be in Angular Zone, but it is!")}run(fn,applyThis,applyArgs){return this._inner.run(fn,applyThis,applyArgs)}runTask(fn,applyThis,applyArgs,name){const zone=this._inner,task=zone.scheduleEventTask("NgZoneEvent: "+name,fn,EMPTY_PAYLOAD,noop,noop);try{return zone.runTask(task,applyThis,applyArgs)}finally{zone.cancelTask(task)}}runGuarded(fn,applyThis,applyArgs){return this._inner.runGuarded(fn,applyThis,applyArgs)}runOutsideAngular(fn){return this._outer.run(fn)}}const EMPTY_PAYLOAD={};function checkStable(zone){if(0==zone._nesting&&!zone.hasPendingMicrotasks&&!zone.isStable)try{zone._nesting++,zone.onMicrotaskEmpty.emit(null)}finally{if(zone._nesting--,!zone.hasPendingMicrotasks)try{zone.runOutsideAngular((()=>zone.onStable.emit(null)))}finally{zone.isStable=!0}}}function updateMicroTaskStatus(zone){zone._hasPendingMicrotasks||(zone.shouldCoalesceEventChangeDetection||zone.shouldCoalesceRunChangeDetection)&&-1!==zone.lastRequestAnimationFrameId?zone.hasPendingMicrotasks=!0:zone.hasPendingMicrotasks=!1}function onEnter(zone){zone._nesting++,zone.isStable&&(zone.isStable=!1,zone.onUnstable.emit(null))}function onLeave(zone){zone._nesting--,checkStable(zone)}new InjectionToken(ngDevMode?"isStable Observable":"",{providedIn:"root",factory:function isStableFactory(){const zone=inject$1(NgZone);let _stable=!0;const isCurrentlyStable=new Observable.c((observer=>{_stable=zone.isStable&&!zone.hasPendingMacrotasks&&!zone.hasPendingMicrotasks,zone.runOutsideAngular((()=>{observer.next(_stable),observer.complete()}))})),isStable=new Observable.c((observer=>{let stableSub;zone.runOutsideAngular((()=>{stableSub=zone.onStable.subscribe((()=>{NgZone.assertNotInAngularZone(),queueMicrotask((()=>{_stable||zone.hasPendingMacrotasks||zone.hasPendingMicrotasks||(_stable=!0,observer.next(!0))}))}))}));const unstableSub=zone.onUnstable.subscribe((()=>{NgZone.assertInAngularZone(),_stable&&(_stable=!1,zone.runOutsideAngular((()=>{observer.next(!1)})))}));return()=>{stableSub.unsubscribe(),unstableSub.unsubscribe()}}));return(0,merge.h)(isCurrentlyStable,isStable.pipe((0,share.u)()))}});class AfterRenderEventManager{constructor(){this.renderDepth=0,this.handler=null}begin(){this.handler?.validateBegin(),this.renderDepth++}end(){ngDevMode&&assertGreaterThan(this.renderDepth,0,"renderDepth must be greater than 0"),this.renderDepth--,0===this.renderDepth&&this.handler?.execute()}ngOnDestroy(){this.handler?.destroy(),this.handler=null}static#_=this.ɵprov=ɵɵdefineInjectable({token:AfterRenderEventManager,providedIn:"root",factory:()=>new AfterRenderEventManager})}function markViewDirty(lView){for(;lView;){lView[FLAGS]|=64;const parent=getLViewParent(lView);if(isRootView(lView)&&!parent)return lView;lView=parent}return null}new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"IS_HYDRATION_DOM_REUSE_ENABLED":"");const PRESERVE_HOST_CONTENT=new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"PRESERVE_HOST_CONTENT":"",{providedIn:"root",factory:()=>false});let currentConsumer=null;function getReactiveLViewConsumer(lView,slot){return lView[slot]??getOrCreateCurrentLViewConsumer()}function commitLViewConsumerIfHasProducers(lView,slot){const consumer=getOrCreateCurrentLViewConsumer();consumer.producerNode?.length&&(lView[slot]=currentConsumer,consumer.lView=lView,currentConsumer=createLViewConsumer())}const REACTIVE_LVIEW_CONSUMER_NODE={...REACTIVE_NODE,consumerIsAlwaysLive:!0,consumerMarkedDirty:node=>{("undefined"==typeof ngDevMode||ngDevMode)&&assertDefined(node.lView,"Updating a signal during template or host binding execution is not allowed."),markViewDirty(node.lView)},lView:null};function createLViewConsumer(){return Object.create(REACTIVE_LVIEW_CONSUMER_NODE)}function getOrCreateCurrentLViewConsumer(){return currentConsumer??=createLViewConsumer(),currentConsumer}const NO_CHANGE="undefined"==typeof ngDevMode||ngDevMode?{__brand__:"NO_CHANGE"}:{};function selectIndexInternal(tView,lView,index,checkNoChangesMode){if(ngDevMode&&function assertIndexInDeclRange(lView,index){const tView=lView[1];assertBetween(HEADER_OFFSET,tView.bindingStartIndex,index)}(lView,index),!checkNoChangesMode){if(!(3&~lView[FLAGS])){const preOrderCheckHooks=tView.preOrderCheckHooks;null!==preOrderCheckHooks&&executeCheckHooks(lView,preOrderCheckHooks,index)}else{const preOrderHooks=tView.preOrderHooks;null!==preOrderHooks&&executeInitAndCheckHooks(lView,preOrderHooks,0,index)}}setSelectedIndex(index)}function ɵɵdirectiveInject(token,flags=InjectFlags.Default){const lView=getLView();if(null===lView)return ngDevMode&&function assertInjectImplementationNotEqual(fn){ngDevMode&&assertNotEqual(_injectImplementation,fn,"Calling ɵɵinject would cause infinite recursion")}(ɵɵdirectiveInject),ɵɵinject(token,flags);const value=getOrCreateInjectable(getCurrentTNode(),lView,resolveForwardRef(token),flags);return ngDevMode&&emitInjectEvent(token,value,flags),value}function createLView(parentLView,tView,context,flags,host,tHostNode,environment,renderer,injector,embeddedViewInjector,hydrationInfo){const lView=tView.blueprint.slice();return lView[HOST]=host,lView[FLAGS]=140|flags,(null!==embeddedViewInjector||parentLView&&2048&parentLView[FLAGS])&&(lView[FLAGS]|=2048),resetPreOrderHookFlags(lView),ngDevMode&&tView.declTNode&&parentLView&&assertTNodeForLView(tView.declTNode,parentLView),lView[PARENT]=lView[DECLARATION_VIEW]=parentLView,lView[CONTEXT]=context,lView[ENVIRONMENT]=environment||parentLView&&parentLView[ENVIRONMENT],ngDevMode&&assertDefined(lView[ENVIRONMENT],"LViewEnvironment is required"),lView[RENDERER]=renderer||parentLView&&parentLView[RENDERER],ngDevMode&&assertDefined(lView[RENDERER],"Renderer is required"),lView[INJECTOR$1]=injector||parentLView&&parentLView[INJECTOR$1]||null,lView[T_HOST]=tHostNode,lView[ID]=function getUniqueLViewId(){return uniqueIdCounter++}(),lView[HYDRATION]=hydrationInfo,lView[EMBEDDED_VIEW_INJECTOR]=embeddedViewInjector,ngDevMode&&assertEqual(2!=tView.type||null!==parentLView,!0,"Embedded views must have parentLView"),lView[DECLARATION_COMPONENT_VIEW]=2==tView.type?parentLView[DECLARATION_COMPONENT_VIEW]:lView,lView}function getOrCreateTNode(tView,index,type,name,attrs){ngDevMode&&0!==index&&assertGreaterThanOrEqual(index,HEADER_OFFSET,"TNodes can't be in the LView header."),ngDevMode&&function assertPureTNodeType(type){2!==type&&1!==type&&4!==type&&8!==type&&32!==type&&16!==type&&64!==type&&throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`)}(type);let tNode=tView.data[index];if(null===tNode)tNode=createTNodeAtIndex(tView,index,type,name,attrs),function isInI18nBlock(){return instructionState.lFrame.inI18n}()&&(tNode.flags|=32);else if(64&tNode.type){tNode.type=type,tNode.value=name,tNode.attrs=attrs;const parent=getCurrentParentTNode();tNode.injectorIndex=null===parent?-1:parent.injectorIndex,ngDevMode&&assertTNodeForTView(tNode,tView),ngDevMode&&assertEqual(index,tNode.index,"Expecting same index")}return setCurrentTNode(tNode,!0),tNode}function createTNodeAtIndex(tView,index,type,name,attrs){const currentTNode=getCurrentTNodePlaceholderOk(),isParent=isCurrentTNodeParent(),parent=isParent?currentTNode:currentTNode&&currentTNode.parent,tNode=tView.data[index]=function createTNode(tView,tParent,type,index,value,attrs){ngDevMode&&0!==index&&assertGreaterThanOrEqual(index,HEADER_OFFSET,"TNodes can't be in the LView header."),ngDevMode&&assertNotSame(attrs,void 0,"'undefined' is not valid value for 'attrs'"),ngDevMode&&ngDevMode.tNode++,ngDevMode&&tParent&&assertTNodeForTView(tParent,tView);let injectorIndex=tParent?tParent.injectorIndex:-1,flags=0;isInSkipHydrationBlock$1()&&(flags|=128);const tNode={type,index,insertBeforeIndex:null,injectorIndex,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags,providerIndexes:0,value,attrs,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:tParent,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0};ngDevMode&&Object.seal(tNode);return tNode}(tView,parent,type,index,name,attrs);return null===tView.firstChild&&(tView.firstChild=tNode),null!==currentTNode&&(isParent?null==currentTNode.child&&null!==tNode.parent&&(currentTNode.child=tNode):null===currentTNode.next&&(currentTNode.next=tNode,tNode.prev=currentTNode)),tNode}function allocExpando(tView,lView,numSlotsToAlloc,initialValue){if(0===numSlotsToAlloc)return-1;ngDevMode&&(assertFirstCreatePass(tView),assertSame(tView,lView[TVIEW],"`LView` must be associated with `TView`!"),assertEqual(tView.data.length,lView.length,"Expecting LView to be same size as TView"),assertEqual(tView.data.length,tView.blueprint.length,"Expecting Blueprint to be same size as TView"),assertFirstUpdatePass(tView));const allocIdx=lView.length;for(let i=0;i<numSlotsToAlloc;i++)lView.push(initialValue),tView.blueprint.push(initialValue),tView.data.push(null);return allocIdx}function executeTemplate(tView,lView,templateFn,rf,context){const consumer=getReactiveLViewConsumer(lView,REACTIVE_TEMPLATE_CONSUMER),prevSelectedIndex=getSelectedIndex(),isUpdatePhase=2&rf;try{setSelectedIndex(-1),isUpdatePhase&&lView.length>HEADER_OFFSET&&selectIndexInternal(tView,lView,HEADER_OFFSET,!!ngDevMode&&isInCheckNoChangesMode());profiler(isUpdatePhase?2:0,context);const effectiveConsumer=isUpdatePhase?consumer:null,prevConsumer=consumerBeforeComputation(effectiveConsumer);try{null!==effectiveConsumer&&(effectiveConsumer.dirty=!1),templateFn(rf,context)}finally{consumerAfterComputation(effectiveConsumer,prevConsumer)}}finally{isUpdatePhase&&null===lView[REACTIVE_TEMPLATE_CONSUMER]&&commitLViewConsumerIfHasProducers(lView,REACTIVE_TEMPLATE_CONSUMER),setSelectedIndex(prevSelectedIndex);profiler(isUpdatePhase?3:1,context)}}function executeContentQueries(tView,tNode,lView){if(isContentQueryHost(tNode)){const prevConsumer=setActiveConsumer(null);try{const start=tNode.directiveStart,end=tNode.directiveEnd;for(let directiveIndex=start;directiveIndex<end;directiveIndex++){const def=tView.data[directiveIndex];def.contentQueries&&def.contentQueries(1,lView[directiveIndex],directiveIndex)}}finally{setActiveConsumer(prevConsumer)}}}function getOrCreateComponentTView(def){const tView=def.tView;if(null===tView||tView.incompleteFirstPass){const declTNode=null;return def.tView=createTView(1,declTNode,def.template,def.decls,def.vars,def.directiveDefs,def.pipeDefs,def.viewQuery,def.schemas,def.consts,def.id)}return tView}function createTView(type,declTNode,templateFn,decls,vars,directives,pipes,viewQuery,schemas,constsOrFactory,ssrId){ngDevMode&&ngDevMode.tView++;const bindingStartIndex=HEADER_OFFSET+decls,initialViewLength=bindingStartIndex+vars,blueprint=function createViewBlueprint(bindingStartIndex,initialViewLength){const blueprint=[];for(let i=0;i<initialViewLength;i++)blueprint.push(i<bindingStartIndex?null:NO_CHANGE);return blueprint}(bindingStartIndex,initialViewLength),consts="function"==typeof constsOrFactory?constsOrFactory():constsOrFactory,tView=blueprint[TVIEW]={type,blueprint,template:templateFn,queries:null,viewQuery,declTNode,data:blueprint.slice().fill(null,bindingStartIndex),bindingStartIndex,expandoStartIndex:initialViewLength,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof directives?directives():directives,pipeRegistry:"function"==typeof pipes?pipes():pipes,firstChild:null,schemas,consts,incompleteFirstPass:!1,ssrId};return ngDevMode&&Object.seal(tView),tView}function locateHostElement(renderer,elementOrSelector,encapsulation,injector){const preserveContent=injector.get(PRESERVE_HOST_CONTENT,false)||encapsulation===ViewEncapsulation.ShadowDom,rootElement=renderer.selectRootElement(elementOrSelector,preserveContent);return function applyRootElementTransform(rootElement){_applyRootElementTransformImpl(rootElement)}(rootElement),rootElement}let _applyRootElementTransformImpl=rootElement=>null;function generatePropertyAliases(aliasMap,directiveIndex,propertyAliases,hostDirectiveAliasMap){for(let publicName in aliasMap)if(aliasMap.hasOwnProperty(publicName)){propertyAliases=null===propertyAliases?{}:propertyAliases;const internalName=aliasMap[publicName];null===hostDirectiveAliasMap?addPropertyAlias(propertyAliases,directiveIndex,publicName,internalName):hostDirectiveAliasMap.hasOwnProperty(publicName)&&addPropertyAlias(propertyAliases,directiveIndex,hostDirectiveAliasMap[publicName],internalName)}return propertyAliases}function addPropertyAlias(propertyAliases,directiveIndex,publicName,internalName){propertyAliases.hasOwnProperty(publicName)?propertyAliases[publicName].push(directiveIndex,internalName):propertyAliases[publicName]=[directiveIndex,internalName]}function initializeDirectives(tView,lView,tNode,directives,exportsMap,hostDirectiveDefs){ngDevMode&&assertFirstCreatePass(tView);for(let i=0;i<directives.length;i++)diPublicInInjector(getOrCreateNodeInjectorForNode(tNode,lView),tView,directives[i].type);!function initTNodeFlags(tNode,index,numberOfDirectives){ngDevMode&&assertNotEqual(numberOfDirectives,tNode.directiveEnd-tNode.directiveStart,"Reached the max number of directives"),tNode.flags|=1,tNode.directiveStart=index,tNode.directiveEnd=index+numberOfDirectives,tNode.providerIndexes=index}(tNode,tView.data.length,directives.length);for(let i=0;i<directives.length;i++){const def=directives[i];def.providersResolver&&def.providersResolver(def)}let preOrderHooksFound=!1,preOrderCheckHooksFound=!1,directiveIdx=allocExpando(tView,lView,directives.length,null);ngDevMode&&assertSame(directiveIdx,tNode.directiveStart,"TNode.directiveStart should point to just allocated space");for(let i=0;i<directives.length;i++){const def=directives[i];tNode.mergedAttrs=mergeHostAttrs(tNode.mergedAttrs,def.hostAttrs),configureViewWithDirective(tView,tNode,lView,directiveIdx,def),saveNameToExportMap(directiveIdx,def,exportsMap),null!==def.contentQueries&&(tNode.flags|=4),null===def.hostBindings&&null===def.hostAttrs&&0===def.hostVars||(tNode.flags|=64);const lifeCycleHooks=def.type.prototype;!preOrderHooksFound&&(lifeCycleHooks.ngOnChanges||lifeCycleHooks.ngOnInit||lifeCycleHooks.ngDoCheck)&&((tView.preOrderHooks??=[]).push(tNode.index),preOrderHooksFound=!0),preOrderCheckHooksFound||!lifeCycleHooks.ngOnChanges&&!lifeCycleHooks.ngDoCheck||((tView.preOrderCheckHooks??=[]).push(tNode.index),preOrderCheckHooksFound=!0),directiveIdx++}!function initializeInputAndOutputAliases(tView,tNode,hostDirectiveDefinitionMap){ngDevMode&&assertFirstCreatePass(tView);const start=tNode.directiveStart,end=tNode.directiveEnd,tViewData=tView.data,tNodeAttrs=tNode.attrs,inputsFromAttrs=[];let inputsStore=null,outputsStore=null;for(let directiveIndex=start;directiveIndex<end;directiveIndex++){const directiveDef=tViewData[directiveIndex],aliasData=hostDirectiveDefinitionMap?hostDirectiveDefinitionMap.get(directiveDef):null,aliasedInputs=aliasData?aliasData.inputs:null,aliasedOutputs=aliasData?aliasData.outputs:null;inputsStore=generatePropertyAliases(directiveDef.inputs,directiveIndex,inputsStore,aliasedInputs),outputsStore=generatePropertyAliases(directiveDef.outputs,directiveIndex,outputsStore,aliasedOutputs);const initialInputs=null===inputsStore||null===tNodeAttrs||isInlineTemplate(tNode)?null:generateInitialInputs(inputsStore,directiveIndex,tNodeAttrs);inputsFromAttrs.push(initialInputs)}null!==inputsStore&&(inputsStore.hasOwnProperty("class")&&(tNode.flags|=8),inputsStore.hasOwnProperty("style")&&(tNode.flags|=16)),tNode.initialInputs=inputsFromAttrs,tNode.inputs=inputsStore,tNode.outputs=outputsStore}(tView,tNode,hostDirectiveDefs)}function invokeDirectivesHostBindings(tView,lView,tNode){const start=tNode.directiveStart,end=tNode.directiveEnd,elementIndex=tNode.index,currentDirectiveIndex=function getCurrentDirectiveIndex(){return instructionState.lFrame.currentDirectiveIndex}();try{setSelectedIndex(elementIndex);for(let dirIndex=start;dirIndex<end;dirIndex++){const def=tView.data[dirIndex],directive=lView[dirIndex];setCurrentDirectiveIndex(dirIndex),null===def.hostBindings&&0===def.hostVars&&null===def.hostAttrs||invokeHostBindingsInCreationMode(def,directive)}}finally{setSelectedIndex(-1),setCurrentDirectiveIndex(currentDirectiveIndex)}}function invokeHostBindingsInCreationMode(def,directive){null!==def.hostBindings&&def.hostBindings(1,directive)}function markAsComponentHost(tView,hostTNode,componentOffset){ngDevMode&&assertFirstCreatePass(tView),ngDevMode&&assertGreaterThan(componentOffset,-1,"componentOffset must be great than -1"),hostTNode.componentOffset=componentOffset,(tView.components??=[]).push(hostTNode.index)}function saveNameToExportMap(directiveIdx,def,exportsMap){if(exportsMap){if(def.exportAs)for(let i=0;i<def.exportAs.length;i++)exportsMap[def.exportAs[i]]=directiveIdx;isComponentDef(def)&&(exportsMap[""]=directiveIdx)}}function configureViewWithDirective(tView,tNode,lView,directiveIndex,def){ngDevMode&&assertGreaterThanOrEqual(directiveIndex,HEADER_OFFSET,"Must be in Expando section"),tView.data[directiveIndex]=def;const directiveFactory=def.factory||(def.factory=getFactoryDef(def.type,!0)),nodeInjectorFactory=new NodeInjectorFactory(directiveFactory,isComponentDef(def),ɵɵdirectiveInject);tView.blueprint[directiveIndex]=nodeInjectorFactory,lView[directiveIndex]=nodeInjectorFactory,function registerHostBindingOpCodes(tView,tNode,directiveIdx,directiveVarsIdx,def){ngDevMode&&assertFirstCreatePass(tView);const hostBindings=def.hostBindings;if(hostBindings){let hostBindingOpCodes=tView.hostBindingOpCodes;null===hostBindingOpCodes&&(hostBindingOpCodes=tView.hostBindingOpCodes=[]);const elementIndx=~tNode.index;(function lastSelectedElementIdx(hostBindingOpCodes){let i=hostBindingOpCodes.length;for(;i>0;){const value=hostBindingOpCodes[--i];if("number"==typeof value&&value<0)return value}return 0})(hostBindingOpCodes)!=elementIndx&&hostBindingOpCodes.push(elementIndx),hostBindingOpCodes.push(directiveIdx,directiveVarsIdx,hostBindings)}}(tView,tNode,directiveIndex,allocExpando(tView,lView,def.hostVars,NO_CHANGE),def)}function writeToDirectiveInput(def,instance,publicName,privateName,value){const prevConsumer=setActiveConsumer(null);try{const inputTransforms=def.inputTransforms;null!==inputTransforms&&inputTransforms.hasOwnProperty(privateName)&&(value=inputTransforms[privateName].call(instance,value)),null!==def.setInput?def.setInput(instance,value,publicName,privateName):instance[privateName]=value}finally{setActiveConsumer(prevConsumer)}}function generateInitialInputs(inputs,directiveIndex,attrs){let inputsToStore=null,i=0;for(;i<attrs.length;){const attrName=attrs[i];if(0!==attrName)if(5!==attrName){if("number"==typeof attrName)break;if(inputs.hasOwnProperty(attrName)){null===inputsToStore&&(inputsToStore=[]);const inputConfig=inputs[attrName];for(let j=0;j<inputConfig.length;j+=2)if(inputConfig[j]===directiveIndex){inputsToStore.push(attrName,inputConfig[j+1],attrs[i+1]);break}}i+=2}else i+=2;else i+=4}return inputsToStore}function createLContainer(hostNative,currentView,native,tNode){ngDevMode&&assertLView(currentView);const lContainer=[hostNative,!0,!1,currentView,null,0,tNode,native,null,null,null];return ngDevMode&&assertEqual(lContainer.length,CONTAINER_HEADER_OFFSET,"Should allocate correct number of slots for LContainer header."),lContainer}function refreshContentQueries(tView,lView){const contentQueries=tView.contentQueries;if(null!==contentQueries)for(let i=0;i<contentQueries.length;i+=2){const queryStartIdx=contentQueries[i],directiveDefIdx=contentQueries[i+1];if(-1!==directiveDefIdx){const directiveDef=tView.data[directiveDefIdx];ngDevMode&&assertDefined(directiveDef,"DirectiveDef not found."),ngDevMode&&assertDefined(directiveDef.contentQueries,"contentQueries function should be defined"),setCurrentQueryIndex(queryStartIdx),directiveDef.contentQueries(2,lView[directiveDefIdx],directiveDefIdx)}}}function addToViewTree(lView,lViewOrLContainer){return lView[CHILD_HEAD]?lView[CHILD_TAIL][NEXT]=lViewOrLContainer:lView[CHILD_HEAD]=lViewOrLContainer,lView[CHILD_TAIL]=lViewOrLContainer,lViewOrLContainer}function executeViewQueryFn(flags,viewQueryFn,component){ngDevMode&&assertDefined(viewQueryFn,"View queries function to execute must be defined."),setCurrentQueryIndex(0);const prevConsumer=setActiveConsumer(null);try{viewQueryFn(flags,component)}finally{setActiveConsumer(prevConsumer)}}function handleError(lView,error){const injector=lView[INJECTOR$1],errorHandler=injector?injector.get(ErrorHandler,null):null;errorHandler&&errorHandler.handleError(error)}function setInputsForProperty(tView,lView,inputs,publicName,value){for(let i=0;i<inputs.length;){const index=inputs[i++],privateName=inputs[i++],instance=lView[index];ngDevMode&&assertIndexInRange(lView,index);writeToDirectiveInput(tView.data[index],instance,publicName,privateName,value)}}function renderComponent(hostLView,componentHostIdx){ngDevMode&&assertEqual(isCreationMode(hostLView),!0,"Should be run in creation mode");const componentView=getComponentLViewByIndex(componentHostIdx,hostLView),componentTView=componentView[TVIEW];!function syncViewWithBlueprint(tView,lView){for(let i=lView.length;i<tView.blueprint.length;i++)lView.push(tView.blueprint[i])}(componentTView,componentView);const hostRNode=componentView[HOST];null!==hostRNode&&null===componentView[HYDRATION]&&(componentView[HYDRATION]=retrieveHydrationInfo(hostRNode,componentView[INJECTOR$1])),renderView(componentTView,componentView,componentView[CONTEXT])}function renderView(tView,lView,context){ngDevMode&&assertEqual(isCreationMode(lView),!0,"Should be run in creation mode"),enterView(lView);try{const viewQuery=tView.viewQuery;null!==viewQuery&&executeViewQueryFn(1,viewQuery,context);const templateFn=tView.template;null!==templateFn&&executeTemplate(tView,lView,templateFn,1,context),tView.firstCreatePass&&(tView.firstCreatePass=!1),tView.staticContentQueries&&refreshContentQueries(tView,lView),tView.staticViewQueries&&executeViewQueryFn(2,tView.viewQuery,context);const components=tView.components;null!==components&&function renderChildComponents(hostLView,components){for(let i=0;i<components.length;i++)renderComponent(hostLView,components[i])}(lView,components)}catch(error){throw tView.firstCreatePass&&(tView.incompleteFirstPass=!0,tView.firstCreatePass=!1),error}finally{lView[FLAGS]&=-5,leaveView()}}class EffectManager{constructor(){this.all=new Set,this.queue=new Map}create(effectFn,destroyRef,allowSignalWrites){const zone="undefined"==typeof Zone?null:Zone.current,w=function watch(fn,schedule,allowSignalWrites){const node=Object.create(WATCH_NODE);allowSignalWrites&&(node.consumerAllowSignalWrites=!0),node.fn=fn,node.schedule=schedule;const registerOnCleanup=cleanupFn=>{node.cleanupFn=cleanupFn};return node.ref={notify:()=>consumerMarkDirty(node),run:()=>{if(node.dirty=!1,node.hasRun&&!consumerPollProducersForChange(node))return;node.hasRun=!0;const prevConsumer=consumerBeforeComputation(node);try{node.cleanupFn(),node.cleanupFn=NOOP_CLEANUP_FN,node.fn(registerOnCleanup)}finally{consumerAfterComputation(node,prevConsumer)}},cleanup:()=>node.cleanupFn()},node.ref}(effectFn,(watch=>{this.all.has(watch)&&this.queue.set(watch,zone)}),allowSignalWrites);let unregisterOnDestroy;this.all.add(w),w.notify();const destroy=()=>{w.cleanup(),unregisterOnDestroy?.(),this.all.delete(w),this.queue.delete(w)};return unregisterOnDestroy=destroyRef?.onDestroy(destroy),{destroy}}flush(){if(0!==this.queue.size)for(const[watch,zone]of this.queue)this.queue.delete(watch),zone?zone.run((()=>watch.run())):watch.run()}get isQueueEmpty(){return 0===this.queue.size}static#_=this.ɵprov=ɵɵdefineInjectable({token:EffectManager,providedIn:"root",factory:()=>new EffectManager})}function computeStaticStyling(tNode,attrs,writeToHost){ngDevMode&&assertFirstCreatePass(getTView(),"Expecting to be called in first template pass only");let styles=writeToHost?tNode.styles:null,classes=writeToHost?tNode.classes:null,mode=0;if(null!==attrs)for(let i=0;i<attrs.length;i++){const value=attrs[i];if("number"==typeof value)mode=value;else if(1==mode)classes=concatStringsWithSpace(classes,value);else if(2==mode){styles=concatStringsWithSpace(styles,value+": "+attrs[++i]+";")}}writeToHost?tNode.styles=styles:tNode.stylesWithoutHost=styles,writeToHost?tNode.classes=classes:tNode.classesWithoutHost=classes}function collectNativeNodes(tView,lView,tNode,result,isProjection=!1){for(;null!==tNode;){ngDevMode&&assertTNodeType(tNode,63);const lNode=lView[tNode.index];null!==lNode&&result.push(unwrapRNode(lNode)),isLContainer(lNode)&&collectNativeNodesInLContainer(lNode,result);const tNodeType=tNode.type;if(8&tNodeType)collectNativeNodes(tView,lView,tNode.child,result);else if(32&tNodeType){const nextRNode=icuContainerIterate(tNode,lView);let rNode;for(;rNode=nextRNode();)result.push(rNode)}else if(16&tNodeType){const nodesInSlot=getProjectionNodes(lView,tNode);if(Array.isArray(nodesInSlot))result.push(...nodesInSlot);else{const parentView=getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);ngDevMode&&assertParentView(parentView),collectNativeNodes(parentView[TVIEW],parentView,nodesInSlot,result,!0)}}tNode=isProjection?tNode.projectionNext:tNode.next}return result}function collectNativeNodesInLContainer(lContainer,result){for(let i=CONTAINER_HEADER_OFFSET;i<lContainer.length;i++){const lViewInAContainer=lContainer[i],lViewFirstChildTNode=lViewInAContainer[TVIEW].firstChild;null!==lViewFirstChildTNode&&collectNativeNodes(lViewInAContainer[TVIEW],lViewInAContainer,lViewFirstChildTNode,result)}lContainer[NATIVE]!==lContainer[HOST]&&result.push(lContainer[NATIVE])}function detectChangesInternal(tView,lView,context,notifyErrorHandler=!0){const environment=lView[ENVIRONMENT],rendererFactory=environment.rendererFactory,afterRenderEventManager=environment.afterRenderEventManager,checkNoChangesMode=!!ngDevMode&&isInCheckNoChangesMode();checkNoChangesMode||(rendererFactory.begin?.(),afterRenderEventManager?.begin());try{refreshView(tView,lView,tView.template,context)}catch(error){throw notifyErrorHandler&&handleError(lView,error),error}finally{checkNoChangesMode||(rendererFactory.end?.(),environment.effectManager?.flush(),afterRenderEventManager?.end())}}function checkNoChangesInternal(tView,lView,context,notifyErrorHandler=!0){setIsInCheckNoChangesMode(!0);try{detectChangesInternal(tView,lView,context,notifyErrorHandler)}finally{setIsInCheckNoChangesMode(!1)}}function refreshView(tView,lView,templateFn,context){ngDevMode&&assertEqual(isCreationMode(lView),!1,"Should be run in update mode");const flags=lView[FLAGS];if(!(256&~flags))return;const isInCheckNoChangesPass=ngDevMode&&isInCheckNoChangesMode();!isInCheckNoChangesPass&&lView[ENVIRONMENT].effectManager?.flush(),enterView(lView);try{resetPreOrderHookFlags(lView),setBindingIndex(tView.bindingStartIndex),null!==templateFn&&executeTemplate(tView,lView,templateFn,2,context);const hooksInitPhaseCompleted=!(3&~flags);if(!isInCheckNoChangesPass)if(hooksInitPhaseCompleted){const preOrderCheckHooks=tView.preOrderCheckHooks;null!==preOrderCheckHooks&&executeCheckHooks(lView,preOrderCheckHooks,null)}else{const preOrderHooks=tView.preOrderHooks;null!==preOrderHooks&&executeInitAndCheckHooks(lView,preOrderHooks,0,null),incrementInitPhaseFlags(lView,0)}if(function markTransplantedViewsForRefresh(lView){for(let lContainer=getFirstLContainer(lView);null!==lContainer;lContainer=getNextLContainer(lContainer)){if(!lContainer[HAS_TRANSPLANTED_VIEWS])continue;const movedViews=lContainer[MOVED_VIEWS];ngDevMode&&assertDefined(movedViews,"Transplanted View flags set but missing MOVED_VIEWS");for(let i=0;i<movedViews.length;i++){const movedLView=movedViews[i],insertionLContainer=movedLView[PARENT];ngDevMode&&assertLContainer(insertionLContainer),markViewForRefresh(movedLView)}}}(lView),detectChangesInEmbeddedViews(lView,2),null!==tView.contentQueries&&refreshContentQueries(tView,lView),!isInCheckNoChangesPass)if(hooksInitPhaseCompleted){const contentCheckHooks=tView.contentCheckHooks;null!==contentCheckHooks&&executeCheckHooks(lView,contentCheckHooks)}else{const contentHooks=tView.contentHooks;null!==contentHooks&&executeInitAndCheckHooks(lView,contentHooks,1),incrementInitPhaseFlags(lView,1)}!function processHostBindingOpCodes(tView,lView){const hostBindingOpCodes=tView.hostBindingOpCodes;if(null===hostBindingOpCodes)return;const consumer=getReactiveLViewConsumer(lView,REACTIVE_HOST_BINDING_CONSUMER);try{for(let i=0;i<hostBindingOpCodes.length;i++){const opCode=hostBindingOpCodes[i];if(opCode<0)setSelectedIndex(~opCode);else{const directiveIdx=opCode,bindingRootIndx=hostBindingOpCodes[++i],hostBindingFn=hostBindingOpCodes[++i];setBindingRootForHostBindings(bindingRootIndx,directiveIdx),consumer.dirty=!1;const prevConsumer=consumerBeforeComputation(consumer);try{hostBindingFn(2,lView[directiveIdx])}finally{consumerAfterComputation(consumer,prevConsumer)}}}}finally{null===lView[REACTIVE_HOST_BINDING_CONSUMER]&&commitLViewConsumerIfHasProducers(lView,REACTIVE_HOST_BINDING_CONSUMER),setSelectedIndex(-1)}}(tView,lView);const components=tView.components;null!==components&&detectChangesInChildComponents(lView,components,0);const viewQuery=tView.viewQuery;if(null!==viewQuery&&executeViewQueryFn(2,viewQuery,context),!isInCheckNoChangesPass)if(hooksInitPhaseCompleted){const viewCheckHooks=tView.viewCheckHooks;null!==viewCheckHooks&&executeCheckHooks(lView,viewCheckHooks)}else{const viewHooks=tView.viewHooks;null!==viewHooks&&executeInitAndCheckHooks(lView,viewHooks,2),incrementInitPhaseFlags(lView,2)}!0===tView.firstUpdatePass&&(tView.firstUpdatePass=!1),isInCheckNoChangesPass||(lView[FLAGS]&=-73),clearViewRefreshFlag(lView)}finally{leaveView()}}function detectChangesInEmbeddedViews(lView,mode){for(let lContainer=getFirstLContainer(lView);null!==lContainer;lContainer=getNextLContainer(lContainer))for(let i=CONTAINER_HEADER_OFFSET;i<lContainer.length;i++){detectChangesInView(lContainer[i],mode)}}function detectChangesInComponent(hostLView,componentHostIdx,mode){ngDevMode&&assertEqual(isCreationMode(hostLView),!1,"Should be run in update mode");detectChangesInView(getComponentLViewByIndex(componentHostIdx,hostLView),mode)}function detectChangesInView(lView,mode){if(!function viewAttachedToChangeDetector(view){return!(128&~view[FLAGS])}(lView))return;const tView=lView[TVIEW],flags=lView[FLAGS];if(80&flags&&0===mode||1024&flags||2===mode)refreshView(tView,lView,tView.template,lView[CONTEXT]);else if(lView[DESCENDANT_VIEWS_TO_REFRESH]>0){detectChangesInEmbeddedViews(lView,1);const components=tView.components;null!==components&&detectChangesInChildComponents(lView,components,1)}}function detectChangesInChildComponents(hostLView,components,mode){for(let i=0;i<components.length;i++)detectChangesInComponent(hostLView,components[i],mode)}class ViewRef{get rootNodes(){const lView=this._lView,tView=lView[TVIEW];return collectNativeNodes(tView,lView,tView.firstChild,[])}constructor(_lView,_cdRefInjectingView){this._lView=_lView,this._cdRefInjectingView=_cdRefInjectingView,this._appRef=null,this._attachedToViewContainer=!1}get context(){return this._lView[CONTEXT]}set context(value){this._lView[CONTEXT]=value}get destroyed(){return!(256&~this._lView[FLAGS])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const parent=this._lView[PARENT];if(isLContainer(parent)){const viewRefs=parent[8],index=viewRefs?viewRefs.indexOf(this):-1;index>-1&&(ngDevMode&&assertEqual(index,parent.indexOf(this._lView)-CONTAINER_HEADER_OFFSET,"An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array."),detachView(parent,index),removeFromArray(viewRefs,index))}this._attachedToViewContainer=!1}destroyLView(this._lView[TVIEW],this._lView)}onDestroy(callback){storeLViewOnDestroy(this._lView,callback)}markForCheck(){markViewDirty(this._cdRefInjectingView||this._lView)}detach(){this._lView[FLAGS]&=-129}reattach(){this._lView[FLAGS]|=128}detectChanges(){detectChangesInternal(this._lView[TVIEW],this._lView,this.context)}checkNoChanges(){ngDevMode&&checkNoChangesInternal(this._lView[TVIEW],this._lView,this.context)}attachToViewContainerRef(){if(this._appRef)throw new RuntimeError(902,ngDevMode&&"This view is already attached directly to the ApplicationRef!");this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function detachViewFromDOM(tView,lView){applyView(tView,lView,lView[RENDERER],2,null,null)}(this._lView[TVIEW],this._lView)}attachToAppRef(appRef){if(this._attachedToViewContainer)throw new RuntimeError(902,ngDevMode&&"This view is already attached to a ViewContainer!");this._appRef=appRef}}class RootViewRef extends ViewRef{constructor(_view){super(_view),this._view=_view}detectChanges(){const lView=this._view;detectChangesInternal(lView[TVIEW],lView,lView[CONTEXT],!1)}checkNoChanges(){if(ngDevMode){const lView=this._view;checkNoChangesInternal(lView[TVIEW],lView,lView[CONTEXT],!1)}}get context(){return null}}class ComponentFactoryResolver extends ComponentFactoryResolver$1{constructor(ngModule){super(),this.ngModule=ngModule}resolveComponentFactory(component){ngDevMode&&function assertComponentType(actual,msg="Type passed in is not ComponentType, it does not have 'ɵcmp' property."){getComponentDef$1(actual)||throwError(msg)}(component);const componentDef=getComponentDef$1(component);return new ComponentFactory(componentDef,this.ngModule)}}function toRefArray(map){const array=[];for(let nonMinified in map)if(map.hasOwnProperty(nonMinified)){const minified=map[nonMinified];array.push({propName:minified,templateName:nonMinified})}return array}class ChainedInjector{constructor(injector,parentInjector){this.injector=injector,this.parentInjector=parentInjector}get(token,notFoundValue,flags){flags=convertToBitFlags(flags);const value=this.injector.get(token,NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR,flags);return value!==NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR||notFoundValue===NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR?value:this.parentInjector.get(token,notFoundValue,flags)}}class ComponentFactory extends ComponentFactory$1{get inputs(){const componentDef=this.componentDef,inputTransforms=componentDef.inputTransforms,refArray=toRefArray(componentDef.inputs);if(null!==inputTransforms)for(const input of refArray)inputTransforms.hasOwnProperty(input.propName)&&(input.transform=inputTransforms[input.propName]);return refArray}get outputs(){return toRefArray(this.componentDef.outputs)}constructor(componentDef,ngModule){super(),this.componentDef=componentDef,this.ngModule=ngModule,this.componentType=componentDef.type,this.selector=stringifyCSSSelectorList(componentDef.selectors),this.ngContentSelectors=componentDef.ngContentSelectors?componentDef.ngContentSelectors:[],this.isBoundToModule=!!ngModule}create(injector,projectableNodes,rootSelectorOrNode,environmentInjector){let realEnvironmentInjector=(environmentInjector=environmentInjector||this.ngModule)instanceof EnvironmentInjector?environmentInjector:environmentInjector?.injector;realEnvironmentInjector&&null!==this.componentDef.getStandaloneInjector&&(realEnvironmentInjector=this.componentDef.getStandaloneInjector(realEnvironmentInjector)||realEnvironmentInjector);const rootViewInjector=realEnvironmentInjector?new ChainedInjector(injector,realEnvironmentInjector):injector,rendererFactory=rootViewInjector.get(RendererFactory2,null);if(null===rendererFactory)throw new RuntimeError(407,ngDevMode&&"Angular was not able to inject a renderer (RendererFactory2). Likely this is due to a broken DI hierarchy. Make sure that any injector used to create this component has a correct parent.");const environment={rendererFactory,sanitizer:rootViewInjector.get(Sanitizer,null),effectManager:rootViewInjector.get(EffectManager,null),afterRenderEventManager:rootViewInjector.get(AfterRenderEventManager,null)},hostRenderer=rendererFactory.createRenderer(null,this.componentDef),elementName=this.componentDef.selectors[0][0]||"div",hostRNode=rootSelectorOrNode?locateHostElement(hostRenderer,rootSelectorOrNode,this.componentDef.encapsulation,rootViewInjector):createElementNode(hostRenderer,elementName,function getNamespace(elementName){const name=elementName.toLowerCase();return"svg"===name?"svg":"math"===name?"math":null}(elementName)),nonSignalFlags=this.componentDef.onPush?576:528,rootFlags=this.componentDef.signals?4608:nonSignalFlags;let hydrationInfo=null;null!==hostRNode&&(hydrationInfo=retrieveHydrationInfo(hostRNode,rootViewInjector,!0));const rootTView=createTView(0,null,null,1,0,null,null,null,null,null,null),rootLView=createLView(null,rootTView,null,rootFlags,null,null,environment,hostRenderer,rootViewInjector,null,hydrationInfo);let component,tElementNode;enterView(rootLView);try{const rootComponentDef=this.componentDef;let rootDirectives,hostDirectiveDefs=null;rootComponentDef.findHostDirectiveDefs?(rootDirectives=[],hostDirectiveDefs=new Map,rootComponentDef.findHostDirectiveDefs(rootComponentDef,rootDirectives,hostDirectiveDefs),rootDirectives.push(rootComponentDef)):rootDirectives=[rootComponentDef];const componentView=function createRootComponentView(tNode,hostRNode,rootComponentDef,rootDirectives,rootView,environment,hostRenderer){const tView=rootView[TVIEW];!function applyRootComponentStyling(rootDirectives,tNode,rNode,hostRenderer){for(const def of rootDirectives)tNode.mergedAttrs=mergeHostAttrs(tNode.mergedAttrs,def.hostAttrs);null!==tNode.mergedAttrs&&(computeStaticStyling(tNode,tNode.mergedAttrs,!0),null!==rNode&&setupStaticAttributes(hostRenderer,rNode,tNode))}(rootDirectives,tNode,hostRNode,hostRenderer);let hydrationInfo=null;null!==hostRNode&&(hydrationInfo=retrieveHydrationInfo(hostRNode,rootView[INJECTOR$1]));const viewRenderer=environment.rendererFactory.createRenderer(hostRNode,rootComponentDef);let lViewFlags=16;rootComponentDef.signals?lViewFlags=4096:rootComponentDef.onPush&&(lViewFlags=64);const componentView=createLView(rootView,getOrCreateComponentTView(rootComponentDef),null,lViewFlags,rootView[tNode.index],tNode,environment,viewRenderer,null,null,hydrationInfo);tView.firstCreatePass&&markAsComponentHost(tView,tNode,rootDirectives.length-1);return addToViewTree(rootView,componentView),rootView[tNode.index]=componentView}(function createRootComponentTNode(lView,rNode){const tView=lView[TVIEW],index=HEADER_OFFSET;return ngDevMode&&assertIndexInRange(lView,index),lView[index]=rNode,getOrCreateTNode(tView,index,2,"#host",null)}(rootLView,hostRNode),hostRNode,rootComponentDef,rootDirectives,rootLView,environment,hostRenderer);tElementNode=getTNode(rootTView,HEADER_OFFSET),hostRNode&&function setRootNodeAttributes(hostRenderer,componentDef,hostRNode,rootSelectorOrNode){if(rootSelectorOrNode)setUpAttributes(hostRenderer,hostRNode,["ng-version",VERSION.full]);else{const{attrs,classes}=function extractAttrsAndClassesFromSelector(selector){const attrs=[],classes=[];let i=1,mode=2;for(;i<selector.length;){let valueOrMarker=selector[i];if("string"==typeof valueOrMarker)2===mode?""!==valueOrMarker&&attrs.push(valueOrMarker,selector[++i]):8===mode&&classes.push(valueOrMarker);else{if(!isPositive(mode))break;mode=valueOrMarker}i++}return{attrs,classes}}(componentDef.selectors[0]);attrs&&setUpAttributes(hostRenderer,hostRNode,attrs),classes&&classes.length>0&&writeDirectClass(hostRenderer,hostRNode,classes.join(" "))}}(hostRenderer,rootComponentDef,hostRNode,rootSelectorOrNode),void 0!==projectableNodes&&function projectNodes(tNode,ngContentSelectors,projectableNodes){const projection=tNode.projection=[];for(let i=0;i<ngContentSelectors.length;i++){const nodesforSlot=projectableNodes[i];projection.push(null!=nodesforSlot?Array.from(nodesforSlot):null)}}(tElementNode,this.ngContentSelectors,projectableNodes),component=function createRootComponent(componentView,rootComponentDef,rootDirectives,hostDirectiveDefs,rootLView,hostFeatures){const rootTNode=getCurrentTNode();ngDevMode&&assertDefined(rootTNode,"tNode should have been already created");const tView=rootLView[TVIEW],native=getNativeByTNode(rootTNode,rootLView);initializeDirectives(tView,rootLView,rootTNode,rootDirectives,null,hostDirectiveDefs);for(let i=0;i<rootDirectives.length;i++){attachPatchData(getNodeInjectable(rootLView,tView,rootTNode.directiveStart+i,rootTNode),rootLView)}invokeDirectivesHostBindings(tView,rootLView,rootTNode),native&&attachPatchData(native,rootLView);ngDevMode&&assertGreaterThan(rootTNode.componentOffset,-1,"componentOffset must be great than -1");const component=getNodeInjectable(rootLView,tView,rootTNode.directiveStart+rootTNode.componentOffset,rootTNode);if(componentView[CONTEXT]=rootLView[CONTEXT]=component,null!==hostFeatures)for(const feature of hostFeatures)feature(component,rootComponentDef);return executeContentQueries(tView,rootTNode,componentView),component}(componentView,rootComponentDef,rootDirectives,hostDirectiveDefs,rootLView,[LifecycleHooksFeature]),renderView(rootTView,rootLView,null)}finally{leaveView()}return new ComponentRef(this.componentType,component,createElementRef(tElementNode,rootLView),rootLView,tElementNode)}}class ComponentRef extends ComponentRef$1{constructor(componentType,instance,location,_rootLView,_tNode){super(),this.location=location,this._rootLView=_rootLView,this._tNode=_tNode,this.previousInputValues=null,this.instance=instance,this.hostView=this.changeDetectorRef=new RootViewRef(_rootLView),this.componentType=componentType}setInput(name,value){const inputData=this._tNode.inputs;let dataValue;if(null!==inputData&&(dataValue=inputData[name])){if(this.previousInputValues??=new Map,this.previousInputValues.has(name)&&Object.is(this.previousInputValues.get(name),value))return;const lView=this._rootLView;setInputsForProperty(lView[TVIEW],lView,dataValue,name,value),this.previousInputValues.set(name,value);markViewDirty(getComponentLViewByIndex(this._tNode.index,lView))}else if(ngDevMode){let message=`Can't set value of the '${name}' input on the '${stringifyForError(this.componentType)}' component. `;message+=`Make sure that the '${name}' property is annotated with @Input() or a mapped @Input('${name}') exists.`,reportUnknownPropertyError(message)}}get injector(){return new NodeInjector(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(callback){this.hostView.onDestroy(callback)}}function LifecycleHooksFeature(){const tNode=getCurrentTNode();ngDevMode&&assertDefined(tNode,"TNode is required"),registerPostOrderHooks(getLView()[TVIEW],tNode)}new Set(["ngh","ng-version","ng-server-context"]);new RegExp(`^(\\d+)*(${REFERENCE_NODE_BODY}|${REFERENCE_NODE_HOST})*(.*)`);"undefined"==typeof ngI18nClosureMode&&(_global.ngI18nClosureMode="undefined"!=typeof goog&&"function"==typeof goog.getMsg);var LocaleDataIndex;!function(LocaleDataIndex){LocaleDataIndex[LocaleDataIndex.LocaleId=0]="LocaleId",LocaleDataIndex[LocaleDataIndex.DayPeriodsFormat=1]="DayPeriodsFormat",LocaleDataIndex[LocaleDataIndex.DayPeriodsStandalone=2]="DayPeriodsStandalone",LocaleDataIndex[LocaleDataIndex.DaysFormat=3]="DaysFormat",LocaleDataIndex[LocaleDataIndex.DaysStandalone=4]="DaysStandalone",LocaleDataIndex[LocaleDataIndex.MonthsFormat=5]="MonthsFormat",LocaleDataIndex[LocaleDataIndex.MonthsStandalone=6]="MonthsStandalone",LocaleDataIndex[LocaleDataIndex.Eras=7]="Eras",LocaleDataIndex[LocaleDataIndex.FirstDayOfWeek=8]="FirstDayOfWeek",LocaleDataIndex[LocaleDataIndex.WeekendRange=9]="WeekendRange",LocaleDataIndex[LocaleDataIndex.DateFormat=10]="DateFormat",LocaleDataIndex[LocaleDataIndex.TimeFormat=11]="TimeFormat",LocaleDataIndex[LocaleDataIndex.DateTimeFormat=12]="DateTimeFormat",LocaleDataIndex[LocaleDataIndex.NumberSymbols=13]="NumberSymbols",LocaleDataIndex[LocaleDataIndex.NumberFormats=14]="NumberFormats",LocaleDataIndex[LocaleDataIndex.CurrencyCode=15]="CurrencyCode",LocaleDataIndex[LocaleDataIndex.CurrencySymbol=16]="CurrencySymbol",LocaleDataIndex[LocaleDataIndex.CurrencyName=17]="CurrencyName",LocaleDataIndex[LocaleDataIndex.Currencies=18]="Currencies",LocaleDataIndex[LocaleDataIndex.Directionality=19]="Directionality",LocaleDataIndex[LocaleDataIndex.PluralCase=20]="PluralCase",LocaleDataIndex[LocaleDataIndex.ExtraData=21]="ExtraData"}(LocaleDataIndex||(LocaleDataIndex={}));var I18nCreateOpCode;!function(I18nCreateOpCode){I18nCreateOpCode[I18nCreateOpCode.SHIFT=2]="SHIFT",I18nCreateOpCode[I18nCreateOpCode.APPEND_EAGERLY=1]="APPEND_EAGERLY",I18nCreateOpCode[I18nCreateOpCode.COMMENT=2]="COMMENT"}(I18nCreateOpCode||(I18nCreateOpCode={}));class NgModuleRef$1{}class EnvironmentNgModuleRefAdapter extends NgModuleRef$1{constructor(config){super(),this.componentFactoryResolver=new ComponentFactoryResolver(this),this.instance=null;const injector=new R3Injector([...config.providers,{provide:NgModuleRef$1,useValue:this},{provide:ComponentFactoryResolver$1,useValue:this.componentFactoryResolver}],config.parent||getNullInjector(),config.debugName,new Set(["environment"]));this.injector=injector,config.runEnvironmentInitializers&&injector.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(callback){this.injector.onDestroy(callback)}}class StandaloneService{constructor(_injector){this._injector=_injector,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(componentDef){if(!componentDef.standalone)return null;if(!this.cachedInjectors.has(componentDef)){const providers=internalImportProvidersFrom(!1,componentDef.type),standaloneInjector=providers.length>0?function createEnvironmentInjector(providers,parent,debugName=null){return new EnvironmentNgModuleRefAdapter({providers,parent,debugName,runEnvironmentInitializers:!0}).injector}([providers],this._injector,`Standalone[${componentDef.type.name}]`):null;this.cachedInjectors.set(componentDef,standaloneInjector)}return this.cachedInjectors.get(componentDef)}ngOnDestroy(){try{for(const injector of this.cachedInjectors.values())null!==injector&&injector.destroy()}finally{this.cachedInjectors.clear()}}static#_=this.ɵprov=ɵɵdefineInjectable({token:StandaloneService,providedIn:"environment",factory:()=>new StandaloneService(ɵɵinject(EnvironmentInjector))})}Symbol.iterator;function addLViewToLContainer(lContainer,lView,index,addToDOM=!0){const tView=lView[TVIEW];if(insertView(tView,lView,lContainer,index),addToDOM){const beforeNode=getBeforeNodeForView(index,lContainer),renderer=lView[RENDERER],parentRNode=nativeParentNode(renderer,lContainer[NATIVE]);null!==parentRNode&&function addViewToDOM(tView,parentTNode,renderer,lView,parentNativeNode,beforeNode){lView[HOST]=parentNativeNode,lView[T_HOST]=parentTNode,applyView(tView,lView,renderer,1,parentNativeNode,beforeNode)}(tView,lContainer[T_HOST],renderer,lView,parentRNode,beforeNode)}}class TemplateRef{static#_=this.__NG_ELEMENT_ID__=injectTemplateRef}const ViewEngineTemplateRef=TemplateRef,R3TemplateRef=class TemplateRef extends ViewEngineTemplateRef{constructor(_declarationLView,_declarationTContainer,elementRef){super(),this._declarationLView=_declarationLView,this._declarationTContainer=_declarationTContainer,this.elementRef=elementRef}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(context,injector){return this.createEmbeddedViewImpl(context,injector)}createEmbeddedViewImpl(context,injector,hydrationInfo){const embeddedLView=function createAndRenderEmbeddedLView(declarationLView,templateTNode,context,options){const embeddedTView=templateTNode.tView;ngDevMode&&assertDefined(embeddedTView,"TView must be defined for a template node."),ngDevMode&&assertTNodeForLView(templateTNode,declarationLView);const embeddedLView=createLView(declarationLView,embeddedTView,context,4096&declarationLView[FLAGS]?4096:16,null,templateTNode,null,null,null,options?.injector??null,options?.hydrationInfo??null),declarationLContainer=declarationLView[templateTNode.index];ngDevMode&&assertLContainer(declarationLContainer),embeddedLView[DECLARATION_LCONTAINER]=declarationLContainer;const declarationViewLQueries=declarationLView[QUERIES];return null!==declarationViewLQueries&&(embeddedLView[QUERIES]=declarationViewLQueries.createEmbeddedView(embeddedTView)),renderView(embeddedTView,embeddedLView,context),embeddedLView}(this._declarationLView,this._declarationTContainer,context,{injector,hydrationInfo});return new ViewRef(embeddedLView)}};function injectTemplateRef(){return createTemplateRef(getCurrentTNode(),getLView())}function createTemplateRef(hostTNode,hostLView){return 4&hostTNode.type?(ngDevMode&&assertDefined(hostTNode.tView,"TView must be allocated"),new R3TemplateRef(hostLView,hostTNode,createElementRef(hostTNode,hostLView))):null}let _findMatchingDehydratedViewImpl=(lContainer,template)=>null;function findMatchingDehydratedView(lContainer,template){return _findMatchingDehydratedViewImpl(lContainer,template)}class ViewContainerRef{static#_=this.__NG_ELEMENT_ID__=injectViewContainerRef}function injectViewContainerRef(){return createContainerRef(getCurrentTNode(),getLView())}const VE_ViewContainerRef=ViewContainerRef,R3ViewContainerRef=class ViewContainerRef extends VE_ViewContainerRef{constructor(_lContainer,_hostTNode,_hostLView){super(),this._lContainer=_lContainer,this._hostTNode=_hostTNode,this._hostLView=_hostLView}get element(){return createElementRef(this._hostTNode,this._hostLView)}get injector(){return new NodeInjector(this._hostTNode,this._hostLView)}get parentInjector(){const parentLocation=getParentInjectorLocation(this._hostTNode,this._hostLView);if(hasParentInjector(parentLocation)){const parentView=getParentInjectorView(parentLocation,this._hostLView),injectorIndex=getParentInjectorIndex(parentLocation);ngDevMode&&assertNodeInjector(parentView,injectorIndex);const parentTNode=parentView[TVIEW].data[injectorIndex+8];return new NodeInjector(parentTNode,parentView)}return new NodeInjector(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(index){const viewRefs=getViewRefs(this._lContainer);return null!==viewRefs&&viewRefs[index]||null}get length(){return this._lContainer.length-CONTAINER_HEADER_OFFSET}createEmbeddedView(templateRef,context,indexOrOptions){let index,injector;"number"==typeof indexOrOptions?index=indexOrOptions:null!=indexOrOptions&&(index=indexOrOptions.index,injector=indexOrOptions.injector);const hydrationInfo=findMatchingDehydratedView(this._lContainer,templateRef.ssrId),viewRef=templateRef.createEmbeddedViewImpl(context||{},injector,hydrationInfo),skipDomInsertion=!!hydrationInfo&&!hasInSkipHydrationBlockFlag(this._hostTNode);return this.insertImpl(viewRef,index,skipDomInsertion),viewRef}createComponent(componentFactoryOrType,indexOrOptions,injector,projectableNodes,environmentInjector){const isComponentFactory=componentFactoryOrType&&!isType(componentFactoryOrType);let index;if(isComponentFactory)ngDevMode&&assertEqual("object"!=typeof indexOrOptions,!0,"It looks like Component factory was provided as the first argument and an options object as the second argument. This combination of arguments is incompatible. You can either change the first argument to provide Component type or change the second argument to be a number (representing an index at which to insert the new component's host view into this container)"),index=indexOrOptions;else{ngDevMode&&(assertDefined(getComponentDef$1(componentFactoryOrType),"Provided Component class doesn't contain Component definition. Please check whether provided class has @Component decorator."),assertEqual("number"!=typeof indexOrOptions,!0,"It looks like Component type was provided as the first argument and a number (representing an index at which to insert the new component's host view into this container as the second argument. This combination of arguments is incompatible. Please use an object as the second argument instead."));const options=indexOrOptions||{};ngDevMode&&options.environmentInjector&&options.ngModuleRef&&throwError("Cannot pass both environmentInjector and ngModuleRef options to createComponent()."),index=options.index,injector=options.injector,projectableNodes=options.projectableNodes,environmentInjector=options.environmentInjector||options.ngModuleRef}const componentFactory=isComponentFactory?componentFactoryOrType:new ComponentFactory(getComponentDef$1(componentFactoryOrType)),contextInjector=injector||this.parentInjector;if(!environmentInjector&&null==componentFactory.ngModule){const result=(isComponentFactory?contextInjector:this.parentInjector).get(EnvironmentInjector,null);result&&(environmentInjector=result)}const componentDef=getComponentDef$1(componentFactory.componentType??{}),dehydratedView=findMatchingDehydratedView(this._lContainer,componentDef?.id??null),rNode=dehydratedView?.firstChild??null,componentRef=componentFactory.create(contextInjector,projectableNodes,rNode,environmentInjector),skipDomInsertion=!!dehydratedView&&!hasInSkipHydrationBlockFlag(this._hostTNode);return this.insertImpl(componentRef.hostView,index,skipDomInsertion),componentRef}insert(viewRef,index){return this.insertImpl(viewRef,index,!1)}insertImpl(viewRef,index,skipDomInsertion){const lView=viewRef._lView;lView[TVIEW];if(ngDevMode&&viewRef.destroyed)throw new Error("Cannot insert a destroyed View in a ViewContainer!");if(function viewAttachedToContainer(view){return isLContainer(view[PARENT])}(lView)){const prevIdx=this.indexOf(viewRef);if(-1!==prevIdx)this.detach(prevIdx);else{const prevLContainer=lView[PARENT];ngDevMode&&assertEqual(isLContainer(prevLContainer),!0,"An attached view should have its PARENT point to a container.");const prevVCRef=new R3ViewContainerRef(prevLContainer,prevLContainer[T_HOST],prevLContainer[PARENT]);prevVCRef.detach(prevVCRef.indexOf(viewRef))}}const adjustedIdx=this._adjustIndex(index),lContainer=this._lContainer;return addLViewToLContainer(lContainer,lView,adjustedIdx,!skipDomInsertion),viewRef.attachToViewContainerRef(),addToArray(getOrCreateViewRefs(lContainer),adjustedIdx,viewRef),viewRef}move(viewRef,newIndex){if(ngDevMode&&viewRef.destroyed)throw new Error("Cannot move a destroyed View in a ViewContainer!");return this.insert(viewRef,newIndex)}indexOf(viewRef){const viewRefsArr=getViewRefs(this._lContainer);return null!==viewRefsArr?viewRefsArr.indexOf(viewRef):-1}remove(index){const adjustedIdx=this._adjustIndex(index,-1),detachedView=detachView(this._lContainer,adjustedIdx);detachedView&&(removeFromArray(getOrCreateViewRefs(this._lContainer),adjustedIdx),destroyLView(detachedView[TVIEW],detachedView))}detach(index){const adjustedIdx=this._adjustIndex(index,-1),view=detachView(this._lContainer,adjustedIdx);return view&&null!=removeFromArray(getOrCreateViewRefs(this._lContainer),adjustedIdx)?new ViewRef(view):null}_adjustIndex(index,shift=0){return null==index?this.length+shift:(ngDevMode&&(assertGreaterThan(index,-1,`ViewRef index must be positive, got ${index}`),assertLessThan(index,this.length+1+shift,"index")),index)}};function getViewRefs(lContainer){return lContainer[8]}function getOrCreateViewRefs(lContainer){return lContainer[8]||(lContainer[8]=[])}function createContainerRef(hostTNode,hostLView){let lContainer;ngDevMode&&assertTNodeType(hostTNode,15);const slotValue=hostLView[hostTNode.index];return isLContainer(slotValue)?lContainer=slotValue:(lContainer=createLContainer(slotValue,hostLView,null,hostTNode),hostLView[hostTNode.index]=lContainer,addToViewTree(hostLView,lContainer)),_locateOrCreateAnchorNode(lContainer,hostLView,hostTNode,slotValue),new R3ViewContainerRef(lContainer,hostTNode,hostLView)}let _locateOrCreateAnchorNode=createAnchorNode;function createAnchorNode(lContainer,hostLView,hostTNode,slotValue){if(lContainer[NATIVE])return;let commentNode;commentNode=8&hostTNode.type?unwrapRNode(slotValue):function insertAnchorNode(hostLView,hostTNode){const renderer=hostLView[RENDERER];ngDevMode&&ngDevMode.rendererCreateComment++;const commentNode=renderer.createComment(ngDevMode?"container":""),hostNative=getNativeByTNode(hostTNode,hostLView);return nativeInsertBefore(renderer,nativeParentNode(renderer,hostNative),commentNode,function nativeNextSibling(renderer,node){return renderer.nextSibling(node)}(renderer,hostNative),!1),commentNode}(hostLView,hostTNode),lContainer[NATIVE]=commentNode}function generateStandaloneInDeclarationsError(type,location){return`${`Unexpected "${stringifyForError(type)}" found in the "declarations" array of the`} ${location}, ${`"${stringifyForError(type)}" is marked as standalone and can't be declared in any NgModule - did you intend to import it instead (by adding it to the "imports" array)?`}`}new WeakMap,new WeakMap;let _nextReferenceId=0;class MetadataOverrider{constructor(){this._references=new Map}overrideMetadata(metadataClass,oldMetadata,override){const props={};if(oldMetadata&&function _valueProps(obj){const props=[];Object.keys(obj).forEach((prop=>{prop.startsWith("_")||props.push(prop)}));let proto=obj;for(;proto=Object.getPrototypeOf(proto);)Object.keys(proto).forEach((protoProp=>{const desc=Object.getOwnPropertyDescriptor(proto,protoProp);!protoProp.startsWith("_")&&desc&&"get"in desc&&props.push(protoProp)}));return props}(oldMetadata).forEach((prop=>props[prop]=oldMetadata[prop])),override.set){if(override.remove||override.add)throw new Error(`Cannot set and add/remove ${(0,core["ɵstringify"])(metadataClass)} at the same time!`);!function setMetadata(metadata,set){for(const prop in set)metadata[prop]=set[prop]}(props,override.set)}return override.remove&&function removeMetadata(metadata,remove,references){const removeObjects=new Set;for(const prop in remove){const removeValue=remove[prop];Array.isArray(removeValue)?removeValue.forEach((value=>{removeObjects.add(_propHashKey(prop,value,references))})):removeObjects.add(_propHashKey(prop,removeValue,references))}for(const prop in metadata){const propValue=metadata[prop];Array.isArray(propValue)?metadata[prop]=propValue.filter((value=>!removeObjects.has(_propHashKey(prop,value,references)))):removeObjects.has(_propHashKey(prop,propValue,references))&&(metadata[prop]=void 0)}}(props,override.remove,this._references),override.add&&function addMetadata(metadata,add){for(const prop in add){const addValue=add[prop],propValue=metadata[prop];null!=propValue&&Array.isArray(propValue)?metadata[prop]=propValue.concat(addValue):metadata[prop]=addValue}}(props,override.add),new metadataClass(props)}}function _propHashKey(propName,propValue,references){let nextObjectId=0;const objectIds=new Map;return`${propName}:${JSON.stringify(propValue,((key,value)=>null!==value&&"object"==typeof value?objectIds.has(value)?objectIds.get(value):(objectIds.set(value,"ɵobj#"+nextObjectId++),value):("function"==typeof value&&(value=function _serializeReference(ref,references){let id=references.get(ref);id||(id=`${(0,core["ɵstringify"])(ref)}${_nextReferenceId++}`,references.set(ref,id));return id}(value,references)),value)))}`}const reflection=new core["ɵReflectionCapabilities"];class OverrideResolver{constructor(){this.overrides=new Map,this.resolved=new Map}addOverride(type,override){const overrides=this.overrides.get(type)||[];overrides.push(override),this.overrides.set(type,overrides),this.resolved.delete(type)}setOverrides(overrides){this.overrides.clear(),overrides.forEach((([type,override])=>{this.addOverride(type,override)}))}getAnnotation(type){const annotations=reflection.annotations(type);for(let i=annotations.length-1;i>=0;i--){const annotation=annotations[i];if(annotation instanceof core.Directive||annotation instanceof core.Component||annotation instanceof core.Pipe||annotation instanceof core.NgModule)return annotation instanceof this.type?annotation:null}return null}resolve(type){let resolved=this.resolved.get(type)||null;if(!resolved){if(resolved=this.getAnnotation(type),resolved){const overrides=this.overrides.get(type);if(overrides){const overrider=new MetadataOverrider;overrides.forEach((override=>{resolved=overrider.overrideMetadata(this.type,resolved,override)}))}}this.resolved.set(type,resolved)}return resolved}}class DirectiveResolver extends OverrideResolver{get type(){return core.Directive}}class ComponentResolver extends OverrideResolver{get type(){return core.Component}}class PipeResolver extends OverrideResolver{get type(){return core.Pipe}}class NgModuleResolver extends OverrideResolver{get type(){return core.NgModule}}var TestingModuleOverride;!function(TestingModuleOverride){TestingModuleOverride[TestingModuleOverride.DECLARATION=0]="DECLARATION",TestingModuleOverride[TestingModuleOverride.OVERRIDE_TEMPLATE=1]="OVERRIDE_TEMPLATE"}(TestingModuleOverride||(TestingModuleOverride={}));class TestBedCompiler{constructor(platform,additionalModuleTypes){this.platform=platform,this.additionalModuleTypes=additionalModuleTypes,this.originalComponentResolutionQueue=null,this.declarations=[],this.imports=[],this.providers=[],this.schemas=[],this.pendingComponents=new Set,this.pendingDirectives=new Set,this.pendingPipes=new Set,this.seenComponents=new Set,this.seenDirectives=new Set,this.overriddenModules=new Set,this.existingComponentStyles=new Map,this.resolvers=function initResolvers(){return{module:new NgModuleResolver,component:new ComponentResolver,directive:new DirectiveResolver,pipe:new PipeResolver}}(),this.componentToModuleScope=new Map,this.initialNgDefs=new Map,this.defCleanupOps=[],this._injector=null,this.compilerProviders=null,this.providerOverrides=[],this.rootProviderOverrides=[],this.providerOverridesByModule=new Map,this.providerOverridesByToken=new Map,this.scopesWithOverriddenProviders=new Set,this.testModuleRef=null;this.testModuleType=class DynamicTestModule{}}setCompilerProviders(providers){this.compilerProviders=providers,this._injector=null}configureTestingModule(moduleDef){void 0!==moduleDef.declarations&&(!function assertNoStandaloneComponents(types,resolver,location){types.forEach((type=>{const component=resolver.resolve(type);if(component&&component.standalone)throw new Error(generateStandaloneInDeclarationsError(type,location))}))}(moduleDef.declarations,this.resolvers.component,'"TestBed.configureTestingModule" call'),this.queueTypeArray(moduleDef.declarations,TestingModuleOverride.DECLARATION),this.declarations.push(...moduleDef.declarations)),void 0!==moduleDef.imports&&(this.queueTypesFromModulesArray(moduleDef.imports),this.imports.push(...moduleDef.imports)),void 0!==moduleDef.providers&&this.providers.push(...moduleDef.providers),void 0!==moduleDef.schemas&&this.schemas.push(...moduleDef.schemas)}overrideModule(ngModule,override){this.overriddenModules.add(ngModule),this.resolvers.module.addOverride(ngModule,override);const metadata=this.resolvers.module.resolve(ngModule);if(null===metadata)throw invalidTypeError(ngModule.name,"NgModule");this.recompileNgModule(ngModule,metadata),this.queueTypesFromModulesArray([ngModule])}overrideComponent(component,override){this.verifyNoStandaloneFlagOverrides(component,override),this.resolvers.component.addOverride(component,override),this.pendingComponents.add(component)}overrideDirective(directive,override){this.verifyNoStandaloneFlagOverrides(directive,override),this.resolvers.directive.addOverride(directive,override),this.pendingDirectives.add(directive)}overridePipe(pipe,override){this.verifyNoStandaloneFlagOverrides(pipe,override),this.resolvers.pipe.addOverride(pipe,override),this.pendingPipes.add(pipe)}verifyNoStandaloneFlagOverrides(type,override){if(override.add?.hasOwnProperty("standalone")||override.set?.hasOwnProperty("standalone")||override.remove?.hasOwnProperty("standalone"))throw new Error(`An override for the ${type.name} class has the \`standalone\` flag. Changing the \`standalone\` flag via TestBed overrides is not supported.`)}overrideProvider(token,provider){let providerDef;providerDef=void 0!==provider.useFactory?{provide:token,useFactory:provider.useFactory,deps:provider.deps||[],multi:provider.multi}:void 0!==provider.useValue?{provide:token,useValue:provider.useValue,multi:provider.multi}:{provide:token};const injectableDef="string"!=typeof token?(0,core["ɵgetInjectableDef"])(token):null,providedIn=null===injectableDef?null:(0,core.resolveForwardRef)(injectableDef.providedIn);if(("root"===providedIn?this.rootProviderOverrides:this.providerOverrides).push(providerDef),this.providerOverridesByToken.set(token,providerDef),null!==injectableDef&&null!==providedIn&&"string"!=typeof providedIn){const existingOverrides=this.providerOverridesByModule.get(providedIn);void 0!==existingOverrides?existingOverrides.push(providerDef):this.providerOverridesByModule.set(providedIn,[providerDef])}}overrideTemplateUsingTestingModule(type,template){const def=type[core["ɵNG_COMP_DEF"]],overrideStyleUrls=!!def&&!isComponentDefPendingResolution(type)&&(()=>{const metadata=this.resolvers.component.resolve(type);return!!metadata.styleUrls&&metadata.styleUrls.length>0})(),override=overrideStyleUrls?{template,styles:[],styleUrls:[]}:{template};this.overrideComponent(type,{set:override}),overrideStyleUrls&&def.styles&&def.styles.length>0&&this.existingComponentStyles.set(type,def.styles),this.componentToModuleScope.set(type,TestingModuleOverride.OVERRIDE_TEMPLATE)}compileComponents(){var _this=this;return(0,asyncToGenerator.A)((function*(){if(_this.clearComponentResolutionQueue(),_this.compileTypesSync()){let resourceLoader,resolver=url=>(resourceLoader||(resourceLoader=_this.injector.get(compiler.ResourceLoader)),Promise.resolve(resourceLoader.get(url)));yield resolveComponentResources(resolver)}}))()}finalize(){this.compileTypesSync(),this.compileTestModule(),this.applyTransitiveScopes(),this.applyProviderOverrides(),this.patchComponentsWithExistingStyles(),this.componentToModuleScope.clear();const parentInjector=this.platform.injector;this.testModuleRef=new core["ɵRender3NgModuleRef"](this.testModuleType,parentInjector,[]),this.testModuleRef.injector.get(core.ApplicationInitStatus).runInitializers();const localeId=this.testModuleRef.injector.get(core.LOCALE_ID,core["ɵDEFAULT_LOCALE_ID"]);return(0,core["ɵsetLocaleId"])(localeId),this.testModuleRef}_compileNgModuleSync(moduleType){this.queueTypesFromModulesArray([moduleType]),this.compileTypesSync(),this.applyProviderOverrides(),this.applyProviderOverridesInScope(moduleType),this.applyTransitiveScopes()}_compileNgModuleAsync(moduleType){var _this2=this;return(0,asyncToGenerator.A)((function*(){_this2.queueTypesFromModulesArray([moduleType]),yield _this2.compileComponents(),_this2.applyProviderOverrides(),_this2.applyProviderOverridesInScope(moduleType),_this2.applyTransitiveScopes()}))()}_getModuleResolver(){return this.resolvers.module}_getComponentFactories(moduleType){return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce(((factories,declaration)=>{const componentDef=declaration.ɵcmp;return componentDef&&factories.push(new core["ɵRender3ComponentFactory"](componentDef,this.testModuleRef)),factories}),[])}compileTypesSync(){let needsAsyncResources=!1;return this.pendingComponents.forEach((declaration=>{needsAsyncResources=needsAsyncResources||isComponentDefPendingResolution(declaration);const metadata=this.resolvers.component.resolve(declaration);if(null===metadata)throw invalidTypeError(declaration.name,"Component");this.maybeStoreNgDef(core["ɵNG_COMP_DEF"],declaration),(0,core["ɵcompileComponent"])(declaration,metadata)})),this.pendingComponents.clear(),this.pendingDirectives.forEach((declaration=>{const metadata=this.resolvers.directive.resolve(declaration);if(null===metadata)throw invalidTypeError(declaration.name,"Directive");this.maybeStoreNgDef(core["ɵNG_DIR_DEF"],declaration),(0,core["ɵcompileDirective"])(declaration,metadata)})),this.pendingDirectives.clear(),this.pendingPipes.forEach((declaration=>{const metadata=this.resolvers.pipe.resolve(declaration);if(null===metadata)throw invalidTypeError(declaration.name,"Pipe");this.maybeStoreNgDef(core["ɵNG_PIPE_DEF"],declaration),(0,core["ɵcompilePipe"])(declaration,metadata)})),this.pendingPipes.clear(),needsAsyncResources}applyTransitiveScopes(){if(this.overriddenModules.size>0){const testingModuleDef=this.testModuleType[core["ɵNG_MOD_DEF"]],affectedModules=this.collectModulesAffectedByOverrides(testingModuleDef.imports);affectedModules.size>0&&affectedModules.forEach((moduleType=>{this.storeFieldOfDefOnType(moduleType,core["ɵNG_MOD_DEF"],"transitiveCompileScopes"),moduleType[core["ɵNG_MOD_DEF"]].transitiveCompileScopes=null}))}const moduleToScope=new Map,getScopeOfModule=moduleType=>{if(!moduleToScope.has(moduleType)){const realType=function isTestingModuleOverride(value){return value===TestingModuleOverride.DECLARATION||value===TestingModuleOverride.OVERRIDE_TEMPLATE}(moduleType)?this.testModuleType:moduleType;moduleToScope.set(moduleType,(0,core["ɵtransitiveScopesFor"])(realType))}return moduleToScope.get(moduleType)};this.componentToModuleScope.forEach(((moduleType,componentType)=>{const moduleScope=getScopeOfModule(moduleType);this.storeFieldOfDefOnType(componentType,core["ɵNG_COMP_DEF"],"directiveDefs"),this.storeFieldOfDefOnType(componentType,core["ɵNG_COMP_DEF"],"pipeDefs"),this.storeFieldOfDefOnType(componentType,core["ɵNG_COMP_DEF"],"tView"),(0,core["ɵpatchComponentDefWithScope"])(componentType.ɵcmp,moduleScope)})),this.componentToModuleScope.clear()}applyProviderOverrides(){const maybeApplyOverrides=field=>type=>{const metadata=(field===core["ɵNG_COMP_DEF"]?this.resolvers.component:this.resolvers.directive).resolve(type);this.hasProviderOverrides(metadata.providers)&&this.patchDefWithProviderOverrides(type,field)};this.seenComponents.forEach(maybeApplyOverrides(core["ɵNG_COMP_DEF"])),this.seenDirectives.forEach(maybeApplyOverrides(core["ɵNG_DIR_DEF"])),this.seenComponents.clear(),this.seenDirectives.clear()}applyProviderOverridesInScope(type){if(!(isStandaloneComponent(type)||function isNgModule(value){return hasNgModuleDef(value)}(type))||this.scopesWithOverriddenProviders.has(type))return;this.scopesWithOverriddenProviders.add(type);const injectorDef=type[core["ɵNG_INJ_DEF"]];if(0!==this.providerOverridesByToken.size)if(isStandaloneComponent(type)){const dependencies=maybeUnwrapFn(getComponentDef(type).dependencies??[]);for(const dependency of dependencies)this.applyProviderOverridesInScope(dependency)}else{const providers=[...injectorDef.providers,...this.providerOverridesByModule.get(type)||[]];this.hasProviderOverrides(providers)&&(this.maybeStoreNgDef(core["ɵNG_INJ_DEF"],type),this.storeFieldOfDefOnType(type,core["ɵNG_INJ_DEF"],"providers"),injectorDef.providers=this.getOverriddenProviders(providers));const imports=maybeUnwrapFn(type[core["ɵNG_MOD_DEF"]].imports);for(const importedModule of imports)this.applyProviderOverridesInScope(importedModule);for(const importedModule of flatten(injectorDef.imports))isModuleWithProviders(importedModule)&&(this.defCleanupOps.push({object:importedModule,fieldName:"providers",originalValue:importedModule.providers}),importedModule.providers=this.getOverriddenProviders(importedModule.providers))}}patchComponentsWithExistingStyles(){this.existingComponentStyles.forEach(((styles,type)=>type[core["ɵNG_COMP_DEF"]].styles=styles)),this.existingComponentStyles.clear()}queueTypeArray(arr,moduleType){for(const value of arr)Array.isArray(value)?this.queueTypeArray(value,moduleType):this.queueType(value,moduleType)}recompileNgModule(ngModule,metadata){this.maybeStoreNgDef(core["ɵNG_MOD_DEF"],ngModule),this.maybeStoreNgDef(core["ɵNG_INJ_DEF"],ngModule),(0,core["ɵcompileNgModuleDefs"])(ngModule,metadata)}queueType(type,moduleType){if(this.resolvers.component.resolve(type))return!isComponentDefPendingResolution(type)&&type.hasOwnProperty(core["ɵNG_COMP_DEF"])||this.pendingComponents.add(type),this.seenComponents.add(type),void(null===moduleType||this.componentToModuleScope.has(type)&&this.componentToModuleScope.get(type)!==TestingModuleOverride.DECLARATION||this.componentToModuleScope.set(type,moduleType));if(this.resolvers.directive.resolve(type))return type.hasOwnProperty(core["ɵNG_DIR_DEF"])||this.pendingDirectives.add(type),void this.seenDirectives.add(type);!this.resolvers.pipe.resolve(type)||type.hasOwnProperty(core["ɵNG_PIPE_DEF"])||this.pendingPipes.add(type)}queueTypesFromModulesArray(arr){const processedDefs=new Set,queueTypesFromModulesArrayRecur=arr=>{for(const value of arr)if(Array.isArray(value))queueTypesFromModulesArrayRecur(value);else if(hasNgModuleDef(value)){const def=value.ɵmod;if(processedDefs.has(def))continue;processedDefs.add(def),this.queueTypeArray(maybeUnwrapFn(def.declarations),value),queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports)),queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports))}else if(isModuleWithProviders(value))queueTypesFromModulesArrayRecur([value.ngModule]);else if(isStandaloneComponent(value)){this.queueType(value,null);const def=getComponentDef(value);if(processedDefs.has(def))continue;processedDefs.add(def);maybeUnwrapFn(def.dependencies??[]).forEach((dependency=>{isStandaloneComponent(dependency)||hasNgModuleDef(dependency)?queueTypesFromModulesArrayRecur([dependency]):this.queueType(dependency,null)}))}};queueTypesFromModulesArrayRecur(arr)}collectModulesAffectedByOverrides(arr){const seenModules=new Set,affectedModules=new Set,calcAffectedModulesRecur=(arr,path)=>{for(const value of arr)if(Array.isArray(value))calcAffectedModulesRecur(value,path);else if(hasNgModuleDef(value)){if(seenModules.has(value)){affectedModules.has(value)&&path.forEach((item=>affectedModules.add(item)));continue}seenModules.add(value),this.overriddenModules.has(value)&&path.forEach((item=>affectedModules.add(item)));const moduleDef=value[core["ɵNG_MOD_DEF"]];calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports),path.concat(value))}};return calcAffectedModulesRecur(arr,[]),affectedModules}maybeStoreNgDef(prop,type){this.initialNgDefs.has(type)||this.initialNgDefs.set(type,new Map);const currentDefs=this.initialNgDefs.get(type);if(!currentDefs.has(prop)){const currentDef=Object.getOwnPropertyDescriptor(type,prop);currentDefs.set(prop,currentDef)}}storeFieldOfDefOnType(type,defField,fieldName){const def=type[defField],originalValue=def[fieldName];this.defCleanupOps.push({object:def,fieldName,originalValue})}clearComponentResolutionQueue(){null===this.originalComponentResolutionQueue&&(this.originalComponentResolutionQueue=new Map),clearResolutionOfComponentResourcesQueue().forEach(((value,key)=>this.originalComponentResolutionQueue.set(key,value)))}restoreComponentResolutionQueue(){null!==this.originalComponentResolutionQueue&&(!function restoreComponentResolutionQueue(queue){componentDefPendingResolution.clear(),queue.forEach(((_,type)=>componentDefPendingResolution.add(type))),componentResourceResolutionQueue=queue}(this.originalComponentResolutionQueue),this.originalComponentResolutionQueue=null)}restoreOriginalState(){forEachRight(this.defCleanupOps,(op=>{op.object[op.fieldName]=op.originalValue})),this.initialNgDefs.forEach(((defs,type)=>{defs.forEach(((descriptor,prop)=>{descriptor?Object.defineProperty(type,prop,descriptor):delete type[prop]}))})),this.initialNgDefs.clear(),this.scopesWithOverriddenProviders.clear(),this.restoreComponentResolutionQueue(),(0,core["ɵsetLocaleId"])(core["ɵDEFAULT_LOCALE_ID"])}compileTestModule(){class RootScopeModule{}(0,core["ɵcompileNgModuleDefs"])(RootScopeModule,{providers:[...this.rootProviderOverrides]});const providers=[(0,core.provideZoneChangeDetection)(),{provide:core.Compiler,useFactory:()=>new R3TestCompiler(this)},...this.providers,...this.providerOverrides],imports=[RootScopeModule,this.additionalModuleTypes,this.imports||[]];(0,core["ɵcompileNgModuleDefs"])(this.testModuleType,{declarations:this.declarations,imports,schemas:this.schemas,providers},!0),this.applyProviderOverridesInScope(this.testModuleType)}get injector(){if(null!==this._injector)return this._injector;const providers=[];return this.platform.injector.get(core.COMPILER_OPTIONS).forEach((opts=>{opts.providers&&providers.push(opts.providers)})),null!==this.compilerProviders&&providers.push(...this.compilerProviders),this._injector=core.Injector.create({providers,parent:this.platform.injector}),this._injector}getSingleProviderOverrides(provider){const token=getProviderToken(provider);return this.providerOverridesByToken.get(token)||null}getProviderOverrides(providers){return providers&&providers.length&&0!==this.providerOverridesByToken.size?flatten(flattenProviders(providers,(provider=>this.getSingleProviderOverrides(provider)||[]))):[]}getOverriddenProviders(providers){if(!providers||!providers.length||0===this.providerOverridesByToken.size)return[];const flattenedProviders=flattenProviders(providers),overrides=this.getProviderOverrides(flattenedProviders),overriddenProviders=[...flattenedProviders,...overrides],final=[],seenOverriddenProviders=new Set;return forEachRight(overriddenProviders,(provider=>{const token=getProviderToken(provider);this.providerOverridesByToken.has(token)?seenOverriddenProviders.has(token)||(seenOverriddenProviders.add(token),final.unshift({...provider,multi:!1})):final.unshift(provider)})),final}hasProviderOverrides(providers){return this.getProviderOverrides(providers).length>0}patchDefWithProviderOverrides(declaration,field){const def=declaration[field];if(def&&def.providersResolver){this.maybeStoreNgDef(field,declaration);const resolver=def.providersResolver,processProvidersFn=providers=>this.getOverriddenProviders(providers);this.storeFieldOfDefOnType(declaration,field,"providersResolver"),def.providersResolver=ngDef=>resolver(ngDef,processProvidersFn)}}}function isStandaloneComponent(value){const def=getComponentDef(value);return!!def?.standalone}function getComponentDef(value){return value.ɵcmp??null}function hasNgModuleDef(value){return value.hasOwnProperty("ɵmod")}function maybeUnwrapFn(maybeFn){return maybeFn instanceof Function?maybeFn():maybeFn}function flatten(values){const out=[];return values.forEach((value=>{Array.isArray(value)?out.push(...flatten(value)):out.push(value)})),out}function identityFn(value){return value}function flattenProviders(providers,mapFn=identityFn){const out=[];for(let provider of providers)(0,core["ɵisEnvironmentProviders"])(provider)&&(provider=provider.ɵproviders),Array.isArray(provider)?out.push(...flattenProviders(provider,mapFn)):out.push(mapFn(provider));return out}function getProviderToken(provider){return function getProviderField(provider,field){return provider&&"object"==typeof provider&&provider[field]}(provider,"provide")||provider}function isModuleWithProviders(value){return value.hasOwnProperty("ngModule")}function forEachRight(values,fn){for(let idx=values.length-1;idx>=0;idx--)fn(values[idx],idx)}function invalidTypeError(name,expectedType){return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`)}class R3TestCompiler{constructor(testBed){this.testBed=testBed}compileModuleSync(moduleType){return this.testBed._compileNgModuleSync(moduleType),new core["ɵNgModuleFactory"](moduleType)}compileModuleAsync(moduleType){var _this3=this;return(0,asyncToGenerator.A)((function*(){return yield _this3.testBed._compileNgModuleAsync(moduleType),new core["ɵNgModuleFactory"](moduleType)}))()}compileModuleAndAllComponentsSync(moduleType){const ngModuleFactory=this.compileModuleSync(moduleType),componentFactories=this.testBed._getComponentFactories(moduleType);return new core.ModuleWithComponentFactories(ngModuleFactory,componentFactories)}compileModuleAndAllComponentsAsync(moduleType){var _this4=this;return(0,asyncToGenerator.A)((function*(){const ngModuleFactory=yield _this4.compileModuleAsync(moduleType),componentFactories=_this4.testBed._getComponentFactories(moduleType);return new core.ModuleWithComponentFactories(ngModuleFactory,componentFactories)}))()}clearCache(){}clearCacheFor(type){}getModuleId(moduleType){const meta=this.testBed._getModuleResolver().resolve(moduleType);return meta&&meta.id||void 0}}let _nextRootElementId=0;class TestBedImpl{constructor(){this.platform=null,this.ngModule=null,this._compiler=null,this._testModuleRef=null,this._activeFixtures=[],this.globalCompilationChecked=!1}static#_=this._INSTANCE=null;static get INSTANCE(){return TestBedImpl._INSTANCE=TestBedImpl._INSTANCE||new TestBedImpl}static initTestEnvironment(ngModule,platform,options){const testBed=TestBedImpl.INSTANCE;return testBed.initTestEnvironment(ngModule,platform,options),testBed}static resetTestEnvironment(){TestBedImpl.INSTANCE.resetTestEnvironment()}static configureCompiler(config){return TestBedImpl.INSTANCE.configureCompiler(config)}static configureTestingModule(moduleDef){return TestBedImpl.INSTANCE.configureTestingModule(moduleDef)}static compileComponents(){return TestBedImpl.INSTANCE.compileComponents()}static overrideModule(ngModule,override){return TestBedImpl.INSTANCE.overrideModule(ngModule,override)}static overrideComponent(component,override){return TestBedImpl.INSTANCE.overrideComponent(component,override)}static overrideDirective(directive,override){return TestBedImpl.INSTANCE.overrideDirective(directive,override)}static overridePipe(pipe,override){return TestBedImpl.INSTANCE.overridePipe(pipe,override)}static overrideTemplate(component,template){return TestBedImpl.INSTANCE.overrideTemplate(component,template)}static overrideTemplateUsingTestingModule(component,template){return TestBedImpl.INSTANCE.overrideTemplateUsingTestingModule(component,template)}static overrideProvider(token,provider){return TestBedImpl.INSTANCE.overrideProvider(token,provider)}static inject(token,notFoundValue,flags){return TestBedImpl.INSTANCE.inject(token,notFoundValue,(0,core["ɵconvertToBitFlags"])(flags))}static get(token,notFoundValue=core.Injector.THROW_IF_NOT_FOUND,flags=core.InjectFlags.Default){return TestBedImpl.INSTANCE.inject(token,notFoundValue,flags)}static runInInjectionContext(fn){return TestBedImpl.INSTANCE.runInInjectionContext(fn)}static createComponent(component){return TestBedImpl.INSTANCE.createComponent(component)}static resetTestingModule(){return TestBedImpl.INSTANCE.resetTestingModule()}static execute(tokens,fn,context){return TestBedImpl.INSTANCE.execute(tokens,fn,context)}static get platform(){return TestBedImpl.INSTANCE.platform}static get ngModule(){return TestBedImpl.INSTANCE.ngModule}initTestEnvironment(ngModule,platform,options){if(this.platform||this.ngModule)throw new Error("Cannot set base providers because it has already been called");TestBedImpl._environmentTeardownOptions=options?.teardown,TestBedImpl._environmentErrorOnUnknownElementsOption=options?.errorOnUnknownElements,TestBedImpl._environmentErrorOnUnknownPropertiesOption=options?.errorOnUnknownProperties,this.platform=platform,this.ngModule=ngModule,this._compiler=new TestBedCompiler(this.platform,this.ngModule),(0,core["ɵsetAllowDuplicateNgModuleIdsForTest"])(!0)}resetTestEnvironment(){this.resetTestingModule(),this._compiler=null,this.platform=null,this.ngModule=null,TestBedImpl._environmentTeardownOptions=void 0,(0,core["ɵsetAllowDuplicateNgModuleIdsForTest"])(!1)}resetTestingModule(){this.checkGlobalCompilationFinished(),(0,core["ɵresetCompiledComponents"])(),null!==this._compiler&&this.compiler.restoreOriginalState(),this._compiler=new TestBedCompiler(this.platform,this.ngModule),(0,core["ɵsetUnknownElementStrictMode"])(this._previousErrorOnUnknownElementsOption??false),(0,core["ɵsetUnknownPropertyStrictMode"])(this._previousErrorOnUnknownPropertiesOption??false);try{this.destroyActiveFixtures()}finally{try{this.shouldTearDownTestingModule()&&this.tearDownTestingModule()}finally{this._testModuleRef=null,this._instanceTeardownOptions=void 0,this._instanceErrorOnUnknownElementsOption=void 0,this._instanceErrorOnUnknownPropertiesOption=void 0}}return this}configureCompiler(config){if(null!=config.useJit)throw new Error("JIT compiler is not configurable via TestBed APIs.");return void 0!==config.providers&&this.compiler.setCompilerProviders(config.providers),this}configureTestingModule(moduleDef){return this.assertNotInstantiated("TestBed.configureTestingModule","configure the test module"),this.checkGlobalCompilationFinished(),this._instanceTeardownOptions=moduleDef.teardown,this._instanceErrorOnUnknownElementsOption=moduleDef.errorOnUnknownElements,this._instanceErrorOnUnknownPropertiesOption=moduleDef.errorOnUnknownProperties,this._previousErrorOnUnknownElementsOption=(0,core["ɵgetUnknownElementStrictMode"])(),(0,core["ɵsetUnknownElementStrictMode"])(this.shouldThrowErrorOnUnknownElements()),this._previousErrorOnUnknownPropertiesOption=(0,core["ɵgetUnknownPropertyStrictMode"])(),(0,core["ɵsetUnknownPropertyStrictMode"])(this.shouldThrowErrorOnUnknownProperties()),this.compiler.configureTestingModule(moduleDef),this}compileComponents(){return this.compiler.compileComponents()}inject(token,notFoundValue,flags){if(token===TestBed)return this;const UNDEFINED={},result=this.testModuleRef.injector.get(token,UNDEFINED,(0,core["ɵconvertToBitFlags"])(flags));return result===UNDEFINED?this.compiler.injector.get(token,notFoundValue,flags):result}get(token,notFoundValue=core.Injector.THROW_IF_NOT_FOUND,flags=core.InjectFlags.Default){return this.inject(token,notFoundValue,flags)}runInInjectionContext(fn){return this.inject(core.EnvironmentInjector).runInContext(fn)}execute(tokens,fn,context){const params=tokens.map((t=>this.inject(t)));return fn.apply(context,params)}overrideModule(ngModule,override){return this.assertNotInstantiated("overrideModule","override module metadata"),this.compiler.overrideModule(ngModule,override),this}overrideComponent(component,override){return this.assertNotInstantiated("overrideComponent","override component metadata"),this.compiler.overrideComponent(component,override),this}overrideTemplateUsingTestingModule(component,template){return this.assertNotInstantiated("TestBed.overrideTemplateUsingTestingModule","Cannot override template when the test module has already been instantiated"),this.compiler.overrideTemplateUsingTestingModule(component,template),this}overrideDirective(directive,override){return this.assertNotInstantiated("overrideDirective","override directive metadata"),this.compiler.overrideDirective(directive,override),this}overridePipe(pipe,override){return this.assertNotInstantiated("overridePipe","override pipe metadata"),this.compiler.overridePipe(pipe,override),this}overrideProvider(token,provider){return this.assertNotInstantiated("overrideProvider","override provider"),this.compiler.overrideProvider(token,provider),this}overrideTemplate(component,template){return this.overrideComponent(component,{set:{template,templateUrl:null}})}createComponent(type){const testComponentRenderer=this.inject(TestComponentRenderer),rootElId="root"+_nextRootElementId++;testComponentRenderer.insertRootElement(rootElId);const componentDef=type.ɵcmp;if(!componentDef)throw new Error(`It looks like '${(0,core["ɵstringify"])(type)}' has not been compiled.`);const noNgZone=this.inject(ComponentFixtureNoNgZone,!1),autoDetect=this.inject(ComponentFixtureAutoDetect,!1),ngZone=noNgZone?null:this.inject(core.NgZone,null),componentFactory=new core["ɵRender3ComponentFactory"](componentDef),initComponent=()=>{const componentRef=componentFactory.create(core.Injector.NULL,[],`#${rootElId}`,this.testModuleRef);return new ComponentFixture(componentRef,ngZone,autoDetect)},fixture=ngZone?ngZone.run(initComponent):initComponent();return this._activeFixtures.push(fixture),fixture}get compiler(){if(null===this._compiler)throw new Error("Need to call TestBed.initTestEnvironment() first");return this._compiler}get testModuleRef(){return null===this._testModuleRef&&(this._testModuleRef=this.compiler.finalize()),this._testModuleRef}assertNotInstantiated(methodName,methodDescription){if(null!==this._testModuleRef)throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. Make sure you are not using \`inject\` before \`${methodName}\`.`)}checkGlobalCompilationFinished(){this.globalCompilationChecked||null!==this._testModuleRef||(0,core["ɵflushModuleScopingQueueAsMuchAsPossible"])(),this.globalCompilationChecked=!0}destroyActiveFixtures(){let errorCount=0;if(this._activeFixtures.forEach((fixture=>{try{fixture.destroy()}catch(e){errorCount++,console.error("Error during cleanup of component",{component:fixture.componentInstance,stacktrace:e})}})),this._activeFixtures=[],errorCount>0&&this.shouldRethrowTeardownErrors())throw Error(`${errorCount} ${1===errorCount?"component":"components"} threw errors during cleanup`)}shouldRethrowTeardownErrors(){const instanceOptions=this._instanceTeardownOptions,environmentOptions=TestBedImpl._environmentTeardownOptions;return!instanceOptions&&!environmentOptions||(instanceOptions?.rethrowErrors??environmentOptions?.rethrowErrors??this.shouldTearDownTestingModule())}shouldThrowErrorOnUnknownElements(){return this._instanceErrorOnUnknownElementsOption??TestBedImpl._environmentErrorOnUnknownElementsOption??false}shouldThrowErrorOnUnknownProperties(){return this._instanceErrorOnUnknownPropertiesOption??TestBedImpl._environmentErrorOnUnknownPropertiesOption??false}shouldTearDownTestingModule(){return this._instanceTeardownOptions?.destroyAfterEach??TestBedImpl._environmentTeardownOptions?.destroyAfterEach??true}tearDownTestingModule(){if(null===this._testModuleRef)return;const testRenderer=this.inject(TestComponentRenderer);try{this._testModuleRef.destroy()}catch(e){if(this.shouldRethrowTeardownErrors())throw e;console.error("Error during cleanup of a testing module",{component:this._testModuleRef.instance,stacktrace:e})}finally{testRenderer.removeAllRootElements?.()}}}const TestBed=TestBedImpl;function getCleanupHook(expectedTeardownValue){return()=>{const testBed=TestBedImpl.INSTANCE;testBed.shouldTearDownTestingModule()===expectedTeardownValue&&(testBed.resetTestingModule(),function resetFakeAsyncZone(){if(fakeAsyncTestModule)return fakeAsyncTestModule.resetFakeAsyncZone();throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage)}())}}globalThis.beforeEach?.(getCleanupHook(!1)),globalThis.afterEach?.(getCleanupHook(!0));class RouterTestingModule{static withRoutes(routes,config){return{ngModule:RouterTestingModule,providers:[{provide:fesm2022_router.bw,multi:!0,useValue:routes},{provide:fesm2022_router.J_,useValue:config||{}}]}}static#_=this.ɵfac=function RouterTestingModule_Factory(t){return new(t||RouterTestingModule)};static#_2=this.ɵmod=core["ɵɵdefineNgModule"]({type:RouterTestingModule,exports:[fesm2022_router.iI]});static#_3=this.ɵinj=core["ɵɵdefineInjector"]({providers:[fesm2022_router.uc,provideLocationMocks(),(0,fesm2022_router.Sn)(fesm2022_router.D7).ɵproviders,{provide:fesm2022_router.bw,multi:!0,useValue:[]}],imports:[fesm2022_router.iI]})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RouterTestingModule,[{type:core.NgModule,args:[{exports:[fesm2022_router.iI],providers:[fesm2022_router.uc,provideLocationMocks(),(0,fesm2022_router.Sn)(fesm2022_router.D7).ɵproviders,{provide:fesm2022_router.bw,multi:!0,useValue:[]}]}]}],null,null);class RootFixtureService{createHarness(){if(this.harness)throw new Error("Only one harness should be created per test.");return this.harness=new RouterTestingHarness(this.getRootFixture()),this.harness}getRootFixture(){return void 0!==this.fixture||(this.fixture=TestBed.createComponent(RootCmp),this.fixture.detectChanges()),this.fixture}static#_=this.ɵfac=function RootFixtureService_Factory(t){return new(t||RootFixtureService)};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:RootFixtureService,factory:RootFixtureService.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RootFixtureService,[{type:core.Injectable,args:[{providedIn:"root"}]}],null,null);class RootCmp{static#_=this.ɵfac=function RootCmp_Factory(t){return new(t||RootCmp)};static#_2=this.ɵcmp=core["ɵɵdefineComponent"]({type:RootCmp,selectors:[["ng-component"]],viewQuery:function RootCmp_Query(rf,ctx){if(1&rf&&core["ɵɵviewQuery"](fesm2022_router.n3,5),2&rf){let _t;core["ɵɵqueryRefresh"](_t=core["ɵɵloadQuery"]())&&(ctx.outlet=_t.first)}},standalone:!0,features:[core["ɵɵStandaloneFeature"]],decls:1,vars:0,template:function RootCmp_Template(rf,ctx){1&rf&&core["ɵɵelement"](0,"router-outlet")},dependencies:[fesm2022_router.n3],encapsulation:2})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RootCmp,[{type:core.Component,args:[{standalone:!0,template:"<router-outlet></router-outlet>",imports:[fesm2022_router.n3]}]}],null,{outlet:[{type:core.ViewChild,args:[fesm2022_router.n3]}]});class RouterTestingHarness{static create(initialUrl){return(0,asyncToGenerator.A)((function*(){const harness=TestBed.inject(RootFixtureService).createHarness();return void 0!==initialUrl&&(yield harness.navigateByUrl(initialUrl)),harness}))()}constructor(fixture){this.fixture=fixture}detectChanges(){this.fixture.detectChanges()}get routeDebugElement(){const outlet=this.fixture.componentInstance.outlet;return outlet&&outlet.isActivated?this.fixture.debugElement.query((v=>v.componentInstance===outlet.component)):null}get routeNativeElement(){return this.routeDebugElement?.nativeElement??null}navigateByUrl(url,requiredRoutedComponentType){var _this=this;return(0,asyncToGenerator.A)((function*(){const router=TestBed.inject(fesm2022_router.Ix);let resolveFn;const redirectTrackingPromise=new Promise((resolve=>{resolveFn=resolve}));(0,fesm2022_router.JS)(TestBed.inject(fesm2022_router.Ix),resolveFn),yield router.navigateByUrl(url),yield redirectTrackingPromise,_this.fixture.detectChanges();const outlet=_this.fixture.componentInstance.outlet;if(outlet&&outlet.isActivated&&outlet.activatedRoute.component){const activatedComponent=outlet.component;if(void 0!==requiredRoutedComponentType&&!(activatedComponent instanceof requiredRoutedComponentType))throw new Error(`Unexpected routed component type. Expected ${requiredRoutedComponentType.name} but got ${activatedComponent.constructor.name}`);return activatedComponent}if(void 0!==requiredRoutedComponentType)throw new Error(`Unexpected routed component type. Expected ${requiredRoutedComponentType.name} but the navigation did not activate any component.`);return null}))()}}}}]);